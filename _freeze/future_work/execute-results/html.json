{
  "hash": "8929ae9f65153ce46801b4a7f4af513b",
  "result": {
    "markdown": "\n# Future work & suggestions\n## Point of interest (POI)\n## Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\n  analysis = c(\"Vulnerability index\"),\n  problem =c(\"Results and conclussions based on aggregated data can be limited and biased\"),\n  suggestion =c(\"Find non-spatial data that can be added using municipality, neighbor or sector ID\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             analysis\n1 Vulnerability index\n                                                                      problem\n1 Results and conclussions based on aggregated data can be limited and biased\n                                                                         suggestion\n1 Find non-spatial data that can be added using municipality, neighbor or sector ID\n```\n:::\n:::\n\n\n## Perforamance\n\n### Flood mask\n\nUsing the dilate and erode method described in the slide 95/187 ([link](https://cdn2.hubspot.net/hubfs/2283855/PostGIS%20Day%202019%20-%20Overview.pdf)) could remove small islands that increase the computational costs. A use case of this technique is observed when simplifying coastlines ([link](https://github.com/rruiz-s/heigit-gima/wiki/2.-Data-preparation#post-scenario))\n\n### Buildings\n#### Download from Overture\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Import buildings and roads from Overture\"}\n## Import data\nlibrary(overturemapsr)\noverture_roads <- record_batch_reader(overture_type = 'segment', bbox = sf::st_bbox(ghs))\noverture_buildings <- record_batch_reader(overture_type = 'buildings', bbox = sf::st_bbox(ghs))\n## Subset data\noverture_roads_subset <- overture_roads |> dplyr::select(c(id, geometry,class,update_time, subtype))\n## Export data\n### Local file\nlibrary(arrow)\nlibrary(sfarrow)\nsfarrow::st_write_parquet(overture_roads, \"overture_roads.parquet\")\n### Database\nlibrary(DBI)\nlibrary(nanoarrow)\nDBI::dbWriteTable(eisenberg_connection, \"overture_roads_subset\", overture_roads_subset)\n```\n:::\n\n\n\n#### Processing in duckdb\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n--- Using Duckdb\nINSTALL spatial;\nLOAD spatial;\n----- Importing buildings & flood extent from file to duckdb\n\n---- Buildings\nCREATE TABLE porto_buildings AS\n    SELECT \n        id,\n        st_geomfromwkb(geometry) as geom\n    FROM \n        'porto_buildings_overture.parquet';\n        \n--- Floodig      \nCREATE TABLE  flood AS\n    SELECT\n        * \n    FROM \n      st_read('flooding_porto_cleaned.geojson');\n---- Filtering building in flood extent\nCREATE TABLE flood_building AS \n    SELECT \n      buildings.*\n    FROM\n      porto_buildings AS buildings,\n      flood \n    WHERE\n      st_intersects(buildings.geom, flood.geom);\n--- Export data\nCOPY flood_building TO\n  'flood_building_v2.gpkg' WITH (FORMAT GDAL, DRIVER 'GPKG');\nCOPY porto_buildings TO \n   'porto_buildings.gpkg' WITH (FORMAT GDAL, DRIVER 'GPKG');\n\n```\n:::\n\n\n### Alternative route\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nCREATE TABLE second_path_net AS\nWITH first_path AS (\nSELECT * FROM pgr_dijkstra(\n\t\t\t'SELECT id,\n\t\t\t\t\t source,\n\t\t\t\t\t target, \n\t\t\t\t\t cost \n\t\t\tFROM porto_alegre_net_pre_component_one',\n\t\t\t7249, 7268,\n\t\t\ttrue))\nSELECT \n\t* \nFROM \n\tporto_alegre_net_pre_component_one\nWHERE\n\tporto_alegre_net_pre_component_one.id NOT IN (select edge from first_path);\n\nSELECT * FROM pgr_dijkstra(\n\t\t\t'SELECT id,\n\t\t\t\t\t source,\n\t\t\t\t\t target, \n\t\t\t\t\t cost \n\t\t\tFROM second_path_net',\n\t\t\t7249, 7268,\n\t\t\ttrue)\n-----2\n\n\nCREATE TABLE pkt_2000 AS\nWITH hospital AS (SELECT \n\th.ds_cnes,\n\tnet.id,\n\th.geom\nFROM hospital_rs_geoportal as h\nLEFT JOIN LATERAL\n\t(SELECT \n\t\tid,\n\t\tthe_geom\n\t FROM\n\t porto_alegre_net_pre_component_one_vertices_pgr as net\n\t ORDER BY h.geom <-> net.the_geom\n\t LIMIT 1) AS net ON TRUE\nWHERE \n\th.ds_cnes = 'IRMANDADE DA SANTA CASA DE MISERICORDIA DE PORTO ALEGRE'),\norigin AS(SELECT * FROM porto_alegre_net_pre_component_one_vertices_pgr \nWHERE  id = 7268)\nSELECT j.path_id, j.node, j.edge, b.cost, b.the_geom FROM pgr_KSP(\n\t\t\t\t\t\t'SELECT id,\n\t\t\t\t\t        source,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tcost \n\t\t\t\t\t\tFROM porto_alegre_net_pre_component_one',\n\t\t\t\t\t\t(SELECT id FROM hospital),\n\t\t\t\t\t\t(SELECT id FROM origin),\n\t\t\t\t\t\t2000) as j\n\t\t\t\t\t\tleft JOIN porto_alegre_net_pre_component_one AS b\n\t\t\t\t  ON j.edge = b.id;\n\nCREATE TABLE road_without_first AS \nSELECT \n\t* \nFROM \n\tporto_alegre_net_pre_component_one  \nWHERE \n\tid NOT IN (SELECT edge FROM pkt_2000 WHERE path_id = 1);\n\t\n\n```\n:::\n\n\n## Visualization\n\n### Data \n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE centrality_both_sankey  AS\nWITH centrality_both_sankey AS (\nSELECT  centrality_pre.bidirectid,\n        centrality_pre.centrality AS centrality_pre,\n        centrality_post.centrality AS centrality_post,\n        centrality_pre.the_geom AS pre_geom,\n        centrality_post.the_geom AS post_geom\nFROM centrality_weighted_100_bidirect_cleaned AS centrality_pre\nFULL OUTER JOIN centrality_weighted_100_bidirect_cleaned_post AS centrality_post\n  ON centrality_pre.bidirectid = centrality_post.bidirectid)\nSELECT \n    bidirectid,\n    centrality_pre,\n    centrality_post,\n    COALESCE(ST_Length(pre_geom::geography)/100, ST_Length(post_geom::geography)/1000) AS geom_length\nFROM \n    centrality_both_sankey;\n\n```\n:::\n\n\n### plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggsankey)\n\n### Flow Chart\ncentrality_both_sankey <- DBI::dbReadTable(eisenberg_connection, \"centrality_both_sankey\")\n\ndf_centrality_both_sankey <- centrality_both_sankey |> \n  mutate(pre_scenario=\n           as.factor(case_when(\n             centrality_pre == 0 ~ \"[0]\",\n             centrality_pre > 0 & centrality_pre <= 146 ~ \"[1-146]\",\n             centrality_pre >= 146 & centrality_pre <=345 ~ \"[146-345]\",\n             centrality_pre >= 345 & centrality_pre <= 633  ~ \"[345-633]\",\n             centrality_pre >= 633 ~ \"[633-1644]\",\n             TRUE ~ \"[0]\")),\n         post_scenario=\n           as.factor(case_when(\n             centrality_post == 0 ~ \"[0]\",\n             centrality_post > 0 & centrality_post <= 146 ~ \"[1-146]\",\n             centrality_post >= 146 & centrality_post <=345 ~ \"[146-345]\",\n             centrality_post >= 345 & centrality_post <= 633  ~ \"[345-633]\",\n             centrality_post >= 633 ~ \"[633-1644]\",\n             TRUE ~ \"[0]\"))) \n\n# HeiGIt --- Create a long format dataset for ggsankey\ndf_centrality_both_sankey_long <- df_centrality_both_sankey |> \n  mutate(\n    pre_scenario = as.character(pre_scenario),\n    post_scenario = as.character(post_scenario)) |> \n  ggsankey::make_long(5:6) \n\n# Create an initial Sankey diagram (not used in final plot, but used to extract data)\nmycolour <- c(\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\")\nnames(mycolour) <- c(unique(df_centrality_both_sankey_long$node)[3],\n                     unique(df_centrality_both_sankey_long$node)[1],\n                     unique(df_centrality_both_sankey_long$node)[2],\n                     unique(df_centrality_both_sankey_long$node)[4],\n                     unique(df_centrality_both_sankey_long$node)[5])\nauxiliar_data <-df_centrality_both_sankey_long |> group_by(node, x) |> count()\ndf_centrality_both_sankey_long$node <- factor(df_centrality_both_sankey_long$node, levels=c(\"[0]\",\n                                                                                            \"[1-146]\",\n                                                                                            \"[146-345]\",\n                                                                                            \"[345-633]\",\n                                                                                            \"[633-1644]\")) \np <- ggplot(df_centrality_both_sankey_long, aes(x = x,\n                                                next_x = next_x,\n                                                node = node,\n                                                next_node = next_node,\n                                                fill = factor(node),\n                                                label = node)) +\n  geom_sankey(flow.alpha = 0.6) +\n  geom_sankey_text() +\n  scale_fill_manual(values = mycolour) + \n  geom_sankey_label( fill=\"white\", alpha=.7) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    plot.background = element_rect(fill = \"grey99\", color = NA)\n  )\n\n# Extract flow, node, and label data from the Sankey diagram\nmoves_flows <- layer_data(p, 1) %>% \n  mutate(height = flow_end_ymax - flow_end_ymin)\n\nmoves_nodes <- layer_data(p, 2)\n\nmoves_labels <- layer_data(p, 3)\n\nf1 <- \"Graphik\"\nf1b <- \"Graphik Compact\"\nf2 <- \"Publico Headline\"\n\n# Apply factor levels to ensure matching with mycolour\nmoves_nodes$label <- factor(moves_nodes$label, levels = names(mycolour))\nmoves_flows$label <- factor(moves_flows$label, levels = names(mycolour))\n\np1 <- ggplot() +\n  # Add flow polygons, highlighting the most common moves and using the correct fill mapping\n  geom_polygon(data = moves_flows, aes(x, y, group = group, fill = label)) +\n  # Add node rectangles with color based on the label\n  geom_rect(data = moves_nodes, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = \"white\"), fill=\"white\") +\n  # Manually scale the fill using the mycolour palette\n  scale_fill_manual(values = mycolour) +\n  # Add labels for the most common moves\n  geom_text(data = moves_labels,\n            aes(x, y, label = label),\n            family = f1b,\n            color = \"black\",\n            size = 6) +\n  labs(\n    title = \"Changes on Connectivity\",\n    subtitle = \"Porto Alegre Settlement\",\n    caption = \"Source: OpenStreetMap · Graphic: Ricardo Ruiz Sánchez inspired by Georgios Karamanis\"\n  ) +\n  theme_void(base_family = f1) +\n  theme(\n    legend.position = \"none\",\n    plot.background = element_rect(fill = \"white\", color = NA),\n    plot.margin = margin(10, 10, 10, 10),\n    plot.title = element_text(size = 30, face = \"bold\", family = f2),\n    plot.subtitle = element_text(size = 15, lineheight = 1, color = \"#676162\"),\n    plot.caption = element_text(hjust = 0, size = 12, \"#676162\")\n  )\n\nggsave(\"plot_flow_chart.jpg\", plot= p1, dpi= 300, width= 10, height= 15)\n\n## Length roads\n### pre-length\ndf_length_pre <- centrality_both_sankey |> select(bidirectid, centrality_pre, geom_length) |>\n  rename(centrality = centrality_pre) |> \n  mutate(\n  category_centrality=\n    as.factor(case_when(\n      centrality == 0 ~ \"[0]\",\n      centrality > 0 & centrality <= 146 ~ \"[1-146]\",\n      centrality >= 146 & centrality <=345 ~ \"[146-345]\",\n      centrality >= 345 & centrality <= 633  ~ \"[345-633]\",\n      centrality >= 633 ~ \"[633-1644]\",\n      TRUE ~ \"[0]\"))) |> \n  dplyr::select(c(geom_length, category_centrality)) |> \n  group_by(category_centrality) |>\n  summarise(total_lenth=sum(geom_length))\ndf_length_pre$event <- \"Road length (%)\"\ndf_length_pre$pct <- as.numeric(round(df_length_pre$total_lenth/(sum(df_length_pre$total_lenth)),4))\n\n## pre-length-plot\nggplot(df_length_pre, aes(x = event, y = pct, fill = category_centrality)) +\n  geom_col() +\n  coord_flip() +\n  scale_fill_manual(values = mycolour) +\n  #theme_minimal() +\n  ggthemes::theme_clean() +\n  labs(x=\"\", y=\"\") +\n  theme(\n    legend.position = \"none\",\n    legend.text = element_text(size = 7),\n    legend.title = element_text(size = 7),\n    legend.background = element_blank(),\n    plot.background = element_blank(),\n    plot.caption = element_text(face = \"italic\",\n                                size = 8,\n                                color = \"grey30\"\n    )\n  ) +\n  guides (\n    fill = guide_legend(nrow =2, byrow = TRUE)\n  ) \n\n## Centralities values\ndf_barplots_sankey <- df_centrality_both_sankey |>\n  pivot_longer(cols=c(\"post_scenario\",\"pre_scenario\"),\n               names_to =\"event\",\n               values_to = \"quartile\")\ncentrality_both_longer <- centrality_both |> pivot_longer(cols=c(pre_scenario, post_scenario),\n                                names_to = \"quartile\",\n                                values_to = \"category\") \ndf_barplots_sankey <- centrality_both_longer |> \n  dplyr::select(c(centrality, quartile, category)) |>\n  group_by(quartile, category) |> summarise(centrality=sum(centrality)) |>\n  mutate(total_perc = centrality/sum(centrality))\n\nggplot(df_barplots_sankey, aes(x = quartile, y = total_perc, fill = category)) +\n  geom_col() +\n  scale_x_discrete(labels=c(\"centrality_post\" = \"Post-flooding\", \"centrality_pre\" = \"Pre-flooding\")) +\n  coord_flip() +\n  scale_fill_manual(values = mycolour) +\n  labs(\n    x = \"Event\",\n    y = \"Centrality (%)\",\n    title = \"Share of centrality per range in the two scenarios\"\n  ) +\n  #theme_minimal() +\n  ggthemes::theme_clean() +\n  theme(\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 7),\n    legend.title = element_text(size = 7),\n    legend.background = element_blank(),\n    plot.background = element_blank(),\n    plot.caption = element_text(face = \"italic\",\n                                size = 8,\n                                color = \"grey30\"\n    )\n  ) +\n  guides (\n    fill = guide_legend(nrow = 1, byrow = TRUE)\n  ) \n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}