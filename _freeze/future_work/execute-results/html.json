{
  "hash": "2b00237ee8460c07bf0e665b0252aacf",
  "result": {
    "markdown": "\n# Future work & suggestions\n## Point of interest (POI)\n## Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\n  analysis = c(\"Vulnerability index\"),\n  problem =c(\"Results and conclussions based on aggregated data can be limited and biased\"),\n  suggestion =c(\"Find non-spatial data that can be added using municipality, neighbor or sector ID\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             analysis\n1 Vulnerability index\n                                                                      problem\n1 Results and conclussions based on aggregated data can be limited and biased\n                                                                         suggestion\n1 Find non-spatial data that can be added using municipality, neighbor or sector ID\n```\n:::\n:::\n\n\n## Perforamance\n\n### Flood mask\n\nUsing the dilate and erode method described in the slide 95/187 ([link](https://cdn2.hubspot.net/hubfs/2283855/PostGIS%20Day%202019%20-%20Overview.pdf)) could remove small islands that increase the computational costs. A use case of this technique is observed when simplifying coastlines ([link](https://github.com/rruiz-s/heigit-gima/wiki/2.-Data-preparation#post-scenario))\n\n### Buildings\n#### Download from Overture\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Import buildings and roads from Overture\"}\n## Import data\nlibrary(overturemapsr)\noverture_roads <- record_batch_reader(overture_type = 'segment', bbox = sf::st_bbox(ghs))\noverture_buildings <- record_batch_reader(overture_type = 'buildings', bbox = sf::st_bbox(ghs))\n## Subset data\noverture_roads_subset <- overture_roads |> dplyr::select(c(id, geometry,class,update_time, subtype))\n## Export data\n### Local file\nlibrary(arrow)\nlibrary(sfarrow)\nsfarrow::st_write_parquet(overture_roads, \"overture_roads.parquet\")\n### Database\nlibrary(DBI)\nlibrary(nanoarrow)\nDBI::dbWriteTable(eisenberg_connection, \"overture_roads_subset\", overture_roads_subset)\n```\n:::\n\n\n\n#### Processing in duckdb\n\n::: {.cell}\n\n```{.sql .cell-code}\n--- Using Duckdb\nINSTALL spatial;\nLOAD spatial;\n----- Importing buildings & flood extent from file to duckdb\nCREATE TABLE porto_buildings AS SELECT id, st_geomfromwkb(geometry) as geom  FROM 'porto_buildings_overture.parquet';\nCREATE TABLE  flood AS SELECT * FROM st_read('flooding_porto_cleaned.geojson');\n---- Filtering building in flood extent\nCREATE TABLE flood_building AS SELECT buildings.* FROM porto_buildings as buildings, flood WHERE st_intersects(buildings.geom, flood.geom);\n--- Export data\nCOPY flood_building TO 'flood_building_v2.gpkg' WITH (FORMAT GDAL, DRIVER 'GPKG');\nCOPY porto_buildings TO 'porto_buildings.gpkg' WITH (FORMAT GDAL, DRIVER 'GPKG');\n---\n\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}