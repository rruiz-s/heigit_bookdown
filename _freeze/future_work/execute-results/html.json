{
  "hash": "28de865b0539a2a481fed82786d6f062",
  "result": {
    "markdown": "\n# Future work & suggestions\n## Point of interest (POI)\n## Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\n  analysis = c(\"Vulnerability index\"),\n  problem =c(\"Results and conclussions based on aggregated data can be limited and biased\"),\n  suggestion =c(\"Find non-spatial data that can be added using municipality, neighbor or sector ID\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             analysis\n1 Vulnerability index\n                                                                      problem\n1 Results and conclussions based on aggregated data can be limited and biased\n                                                                         suggestion\n1 Find non-spatial data that can be added using municipality, neighbor or sector ID\n```\n:::\n:::\n\n\n### Bairros\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n# import the data : shp2pgsql -D -I -s 4674 -W \"LATIN1\" '43SEE250GC_SIR.shp' barrios_brasil | psql -p 25432 -U docker -d gis -h localhost\n\nCREATE TABLE brasil_porto_barrios AS\nSELECT \n\tnm_bairro,\n\tst_union(brasil_barrios_4326.geom_4326)\nFROM\n\tbrasil_barrios_4326,\n\tghs_aoi_porto_alegre\nWHERE \n brasil_barrios_4326.nm_bairro IS NOT NULL\n AND\n \tst_intersects(brasil_barrios_4326.geom_4326,\n \t\t\t\tghs_aoi_porto_alegre.geom)\nGROUP BY \n\tnm_bairro;\n```\n:::\n\n\n## Perforamance\n\n### Flood mask\n\nUsing the dilate and erode method described in the slide 95/187 ([link](https://cdn2.hubspot.net/hubfs/2283855/PostGIS%20Day%202019%20-%20Overview.pdf)) could remove small islands that increase the computational costs. A use case of this technique is observed when simplifying coastlines ([link](https://github.com/rruiz-s/heigit-gima/wiki/2.-Data-preparation#post-scenario))\n\n### Buildings\n#### Download from Overture\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Import buildings and roads from Overture\"}\n## Import data\nlibrary(overturemapsr)\nghs <- st_read(eisenberg_connection, \"ghs_aoi_porto_alegre\")\noverture_roads <- record_batch_reader(overture_type = 'segment', bbox = sf::st_bbox(ghs))\noverture_buildings <- record_batch_reader(overture_type = 'building', bbox = sf::st_bbox(ghs))\n## Subset data\noverture_roads_subset <- overture_roads |> dplyr::select(c(id, geometry,class,update_time, subtype))\n## Export data\n### Local file\nlibrary(arrow)\nlibrary(sfarrow)\nsfarrow::st_write_parquet(overture_roads, \"overture_roads.parquet\")\n### Database\nlibrary(DBI)\nlibrary(nanoarrow)\nDBI::dbWriteTable(eisenberg_connection, \"overture_roads_subset\", overture_roads_subset)\n```\n:::\n\n\n\n#### Processing in duckdb\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n--- Using Duckdb\nINSTALL spatial;\nLOAD spatial;\n----- Importing buildings & flood extent from file to duckdb\n\n---- Buildings\nCREATE TABLE porto_buildings AS\n    SELECT \n        id,\n        st_geomfromwkb(geometry) as geom\n    FROM \n        'porto_buildings_overture.parquet';\n        \n--- Floodig      \nCREATE TABLE  flood AS\n    SELECT\n        * \n    FROM \n      st_read('flooding_porto_cleaned.geojson');\n---- Filtering building in flood extent\nCREATE TABLE flood_building AS \n    SELECT \n      buildings.*\n    FROM\n      porto_buildings AS buildings,\n      flood \n    WHERE\n      st_intersects(buildings.geom, flood.geom);\n--- Export data\nCOPY flood_building TO\n  'flood_building_v2.gpkg' WITH (FORMAT GDAL, DRIVER 'GPKG');\nCOPY porto_buildings TO \n   'porto_buildings.gpkg' WITH (FORMAT GDAL, DRIVER 'GPKG');\n\n```\n:::\n\n\n\n## Alternative route\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nCREATE TABLE second_path_net AS\nWITH first_path AS (\nSELECT * FROM pgr_dijkstra(\n\t\t\t'SELECT id,\n\t\t\t\t\t source,\n\t\t\t\t\t target, \n\t\t\t\t\t cost \n\t\t\tFROM porto_alegre_net_pre_component_one',\n\t\t\t7249, 7268,\n\t\t\ttrue))\nSELECT \n\t* \nFROM \n\tporto_alegre_net_pre_component_one\nWHERE\n\tporto_alegre_net_pre_component_one.id NOT IN (select edge from first_path);\n\nSELECT * FROM pgr_dijkstra(\n\t\t\t'SELECT id,\n\t\t\t\t\t source,\n\t\t\t\t\t target, \n\t\t\t\t\t cost \n\t\t\tFROM second_path_net',\n\t\t\t7249, 7268,\n\t\t\ttrue)\n-----2\n\n\nCREATE TABLE pkt_2000 AS\nWITH hospital AS (SELECT \n\th.ds_cnes,\n\tnet.id,\n\th.geom\nFROM hospital_rs_geoportal as h\nLEFT JOIN LATERAL\n\t(SELECT \n\t\tid,\n\t\tthe_geom\n\t FROM\n\t porto_alegre_net_pre_component_one_vertices_pgr as net\n\t ORDER BY h.geom <-> net.the_geom\n\t LIMIT 1) AS net ON TRUE\nWHERE \n\th.ds_cnes = 'IRMANDADE DA SANTA CASA DE MISERICORDIA DE PORTO ALEGRE'),\norigin AS(SELECT * FROM porto_alegre_net_pre_component_one_vertices_pgr \nWHERE  id = 7268)\nSELECT j.path_id, j.node, j.edge, b.cost, b.the_geom FROM pgr_KSP(\n\t\t\t\t\t\t'SELECT id,\n\t\t\t\t\t        source,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tcost \n\t\t\t\t\t\tFROM porto_alegre_net_pre_component_one',\n\t\t\t\t\t\t(SELECT id FROM hospital),\n\t\t\t\t\t\t(SELECT id FROM origin),\n\t\t\t\t\t\t2000) as j\n\t\t\t\t\t\tleft JOIN porto_alegre_net_pre_component_one AS b\n\t\t\t\t  ON j.edge = b.id;\n\nCREATE TABLE road_without_first AS \nSELECT \n\t* \nFROM \n\tporto_alegre_net_pre_component_one  \nWHERE \n\tid NOT IN (SELECT edge FROM pkt_2000 WHERE path_id = 1);\n\t\n\t-----3\n\tWITH paths AS (\n  SELECT \n    path_id,\n    edge,\n    agg_cost,\n    SUM(agg_cost) OVER (PARTITION BY path_id ORDER BY seq ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cum_sum,\n    SUM(agg_cost) OVER (PARTITION BY path_id) AS total_cost\n  FROM \n    your_table\n),\nfiltered_paths AS (\n  SELECT \n    path_id,\n    edge,\n    agg_cost,\n    cum_sum,\n    total_cost\n  FROM \n    paths\n  WHERE \n    cum_sum > 0.25 * total_cost -- remove the first 25%\n    AND cum_sum < 0.75 * total_cost -- remove the last 25%\n)\nSELECT \n  path_id, \n  edge, \n  agg_cost \nFROM \n  filtered_paths;\n  \n  ----5\n  WITH hospital AS (SELECT \n\th.ds_cnes,\n\tnet.id,\n\th.geom\nFROM hospital_rs_geoportal as h\nLEFT JOIN LATERAL\n\t(SELECT \n\t\tid,\n\t\tthe_geom\n\t FROM\n\t porto_alegre_net_pre_component_one_vertices_pgr as net\n\t ORDER BY h.geom <-> net.the_geom\n\t LIMIT 1) AS net ON TRUE\nWHERE \n\th.ds_cnes = 'IRMANDADE DA SANTA CASA DE MISERICORDIA DE PORTO ALEGRE'),\norigin AS(SELECT\n\t\t\t\t* \n\t\t  FROM \n\t\t  \t\tporto_alegre_net_pre_component_one_vertices_pgr \nWHERE  id = 7268),\ntable_ksp AS (\nSELECT j.seq, j.path_id, j.path_seq, j.node, j.edge, j.agg_cost,j.cost,\n\tb.the_geom, b.target, b.source, b.id FROM pgr_KSP(\n\t\t\t\t\t\t'SELECT id,\n\t\t\t\t\t        source,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tcost \n\t\t\t\t\t\tFROM porto_alegre_net_pre_component_one',\n\t\t\t\t\t\t(SELECT id FROM hospital),\n\t\t\t\t\t\t(SELECT\n\t\t\t\t\t\t\tid \n\t\t\t\t\t\tFROM \n\t\t\t\t\t\t\torigin,\n\t\t\t\t\t\t\textract_ksp_segments\n\t\t\t\t\t\tWHERE\n\t\t\t\t\t\t\torigin.id NOT IN (\n\t\t\t\t\t\t\t\tSELECT \n\t\t\t\t\t\t\t\t\tid \n\t\t\t\t\t\t\t\tFROM \n\t\t\t\t\t\t\t\t\textract_ksp_segments\n\t\t\t\t\t\t\t\tWHERE\n\t\t\t\t\t\t\t\t\tpath_id = 1)),\n\t\t\t\t\t\t3) as j\n\t\t\t\t\t\tleft JOIN porto_alegre_net_pre_component_one AS b\n\t\t\t\t  ON j.edge = b.id)\nSELECT  * FROM table_ksp;\n\n```\n:::\n\n\nThis second one does work without creating two segments of networks. It just increased the costs dinamically. This is inspired by [post](https://gis-ops.com/pgrouting-customize-routing-pleasant-hiking/) and [post](https://gis.stackexchange.com/questions/432741/creating-two-costs-in-pgrouting)\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n---- Obtain the shortest path as usual\nCREATE TABLE first_path_dijkstra AS\nSELECT \n\t\tseq,\n\t\tpath_seq,\n\t\tstart_vid,\n\t\tend_vid,\n\t\tnode,\n\t\tedge,\n\t\tnet.the_geom \nFROM  pgr_dijkstra('\n\t\t\t\tSELECT \n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tcost\n\t\t\t\tFROM porto_alegre_net_largest',\n\t\t\t\t9372,\n\t\t\t\t1084) AS path\n\tLEFT JOIN porto_alegre_net_pre_component_one AS net\n\tON path.edge = net.id;\n---- detected the shortest path and then increased cost two fold\nCREATE TABLE dijkstra_second_route AS\nWITH pgr_ksp_table AS (\nSELECT \n\t*\nFROM  pgr_ksp('\n\t\t\t\tSELECT \n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tcost\n\t\t\t\tFROM porto_alegre_net_largest',\n\t\t\t\t9372,\n\t\t\t\t1084,\n\t\t\t\t3,\n\t\t\t\ttrue)), ----node 9372, network = source, target)\nsecond_route AS (\n\t\t\tSELECT \n\t\t\tnet.*,\n\t\t\tCASE \n\t\t\t\tWHEN route.node = net.source THEN net.cost * 2\n\t\t\t\tELSE net.cost\n\t\t\tEND AS cost_updated\n\t\t\tFROM \t\t\t\n\t\t\t\tporto_alegre_net_largest AS net\n\t\t\tLEFT JOIN \n\t\t\t\tpgr_ksp_table  AS route \n\t\t\tON \t\n\t\t\t\troute.edge= net.id)\t\n\t\tSELECT * FROM second_route;\n\n---- Create spatial index\t\nCREATE INDEX idx_ ON dijkstra_second_route USING gist(the_geom);\nCREATE INDEX dijkstra_second_route_source_source ON dijkstra_second_route USING btree(source);\nCREATE INDEX dijkstra_second_route_source_target ON dijkstra_second_route USING btree(target);\n\n---- obtain the second shortest path, since the first-path has now higher \nCREATE TABLE second_path_dikstra AS\nSELECT \n\t\t\tseq,\n\t\t\tpath_seq,\n\t\t\tstart_vid,\n\t\t\tend_vid,\n\t\t\tnode,\n\t\t\tedge,\n\t\t\tnet.the_geom \n\t\tFROM \n\t\t\tpgr_Dijkstra('\n\t\t\t\t\tSELECT\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tcost_updated AS cost\n\t\t\t\t\tFROM\n\t\t\t\t\t\tdijkstra_second_route',\n\t\t\t\t\t\t9372,\n\t\t\t\t\t\t1084)  AS path\n\t\tLEFT JOIN\n\t\t\t\tdijkstra_second_route AS net ON\n\t\t\tpath.edge = net.id\n\n```\n:::\n\n\nUsing this strategy, the following code create 3 alternative routes obtaining the final table \"paths_linestring_table\".\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE first_path_6211 AS\nSELECT \n\t\tseq,\n\t\tpath_seq,\n\t\tstart_vid,\n\t\tend_vid,\n\t\tnode,\n\t\tedge,\n\t\tnet.the_geom,\n\t\t1 AS path\nFROM  pgr_dijkstra('\n\t\t\t\tSELECT \n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tcost\n\t\t\t\tFROM porto_alegre_net_largest',\n\t\t\t\t6211,\n\t\t\t\tARRAY(SELECT id FROM hospital_rs_node_v2),\n\t\t\t\tdirected := TRUE) AS path\n\tLEFT JOIN porto_alegre_net_largest AS net\n\tON path.edge = net.id;\n---- detected the shortest path and then increased cost two fold\n\nDROP TABLE dijkstra_second_route_6211;\nCREATE TABLE dijkstra_second_route_6211 AS\nWITH pgr_doubled_dijkstra AS (\nSELECT \n\t*\nFROM  pgr_dijkstra('\n\t\t\t\tSELECT \n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tcost\n\t\t\t\tFROM porto_alegre_net_largest',\n\t\t\t\t6211,\n\t\t\t\tARRAY(SELECT id FROM hospital_rs_node_v2),\n\t\t\t\tdirected:=true)), ----node 9372, network = source, target)\nsecond_route AS (\n\t\t\tSELECT \n\t\t\tnet.*,\n\t\t\tCASE \n\t\t\t\tWHEN route.node = net.source THEN net.cost * 20\n\t\t\t\tELSE net.cost\n\t\t\tEND AS cost_updated\n\t\t\tFROM \t\t\t\n\t\t\t\tporto_alegre_net_largest AS net\n\t\t\tLEFT JOIN \n\t\t\t\tpgr_doubled_dijkstra  AS route \n\t\t\tON \t\n\t\t\t\troute.edge= net.id)\t\n\t\tSELECT * FROM second_route;\n\n---- Create spatial index\t\nCREATE INDEX idx_second_6211 ON dijkstra_second_route_6211 USING gist(the_geom);\nCREATE INDEX idx_second_6211_source ON dijkstra_second_route_6211 USING btree(source);\nCREATE INDEX idx_second_6211_target ON dijkstra_second_route_6211 USING btree(target);\n\n---- obtain the second shortest path, since the first-path has now higher \nDROP TABLE second_path_dikstra_6211;\nCREATE TABLE second_path_dikstra_6211 AS\nSELECT \n\t\t\tseq,\n\t\t\tpath_seq,\n\t\t\tstart_vid,\n\t\t\tend_vid,\n\t\t\tnode,\n\t\t\tedge,\n\t\t\tnet.the_geom,\n\t\t\t2 AS path\n\t\tFROM \n\t\t\tpgr_Dijkstra('\n\t\t\t\t\tSELECT\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tcost_updated AS cost\n\t\t\t\t\tFROM\n\t\t\t\t\t\tdijkstra_second_route_6211',\n\t\t\t\t\t6211,\n\t\t\t\t\tARRAY(SELECT id FROM hospital_rs_node_v2))  AS path\n\t\tLEFT JOIN\n\t\t\t\tdijkstra_second_route_6211 AS net ON\n\t\t\tpath.edge = net.id;\n\t\t\t\n\t\t\tselect * from second_path_dikstra_6211;\n\t\t\n\t\t\n\t\t\n----- 3 path\nSELECT * FROM dijkstra_second_route_6211;\t\t\n\nDROP TABLE dijkstra_third_route_6211;\nCREATE TABLE dijkstra_third_route_6211 AS\nWITH pgr_doubled_dijkstra AS (\nSELECT \n\t*\nFROM  pgr_dijkstra('\n\t\t\t\tSELECT \n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tcost_updated AS cost\n\t\t\t\tFROM dijkstra_second_route_6211',\n\t\t\t\t6211,\n\t\t\t\tARRAY(SELECT id FROM hospital_rs_node_v2),\n\t\t\t\tdirected:=true)), ----node 9372, network = source, target)\nsecond_route AS (\n\t\t\tSELECT \n\t\t\tnet.*,\n\t\t\tCASE \n\t\t\t\tWHEN route.node = net.source THEN net.cost_updated * 20\n\t\t\t\tELSE net.cost_updated\n\t\t\tEND AS cost_updated_nd\n\t\t\tFROM \t\t\t\n\t\t\t\tdijkstra_second_route_6211 AS net\n\t\t\tLEFT JOIN \n\t\t\t\tpgr_doubled_dijkstra  AS route \n\t\t\tON \t\n\t\t\t\troute.edge= net.id)\t\n\t\tSELECT * FROM second_route;\n\t----\n\nDROP TABLE third_path_dikstra_6211 ;\nCREATE TABLE third_path_dikstra_6211 AS\nSELECT \n\t\t\tseq,\n\t\t\tpath_seq,\n\t\t\tstart_vid,\n\t\t\tend_vid,\n\t\t\tnode,\n\t\t\tedge,\n\t\t\tnet.the_geom,\n\t\t\t3 AS path\n\t\tFROM \n\t\t\tpgr_Dijkstra('\n\t\t\t\t\tSELECT\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tcost_updated_nd AS cost\n\t\t\t\t\tFROM\n\t\t\t\t\t\tdijkstra_third_route_6211',\n\t\t\t\t\t6211,\n\t\t\t\t\tARRAY(SELECT id FROM hospital_rs_node_v2))  AS path\n\t\tLEFT JOIN\n\t\t\t\tdijkstra_third_route_6211 AS net ON\n\t\t\tpath.edge = net.id;\n\t\t\t\n\t\t\tselect * from dijkstra_third_route_6211;\t\n\t\t\n\nCREATE TABLE three_alternative_paths AS \nSELECT * FROM first_path_6211\nUNION\nSELECT * FROM second_path_dikstra_6211\nUNION\nSELECT * FROM third_path_dikstra_6211\n\nCREATE TABLE three_alternative_paths_20 AS \nSELECT * FROM first_path_6211\nUNION\nSELECT * FROM second_path_dikstra_6211\nUNION\nSELECT * FROM third_path_dikstra_6211\n\nCREATE TABLE ernesto_three_alternatives AS\nSELECT\nalternative_paths.*,\nhospitals.ds_cnes,\nhospitals.cd_cnes\nFROM \nthree_alternative_paths AS alternative_paths\nJOIN hospital_rs_node_v2 AS hospitals\nON hospitals.id = alternative_paths.end_vid\nWHERE end_vid = 1743;\n\n\nCREATE TABLE ernesto_three_alternatives_20 AS\nSELECT\nalternative_paths.*,\nhospitals.ds_cnes,\nhospitals.cd_cnes\nFROM \nthree_alternative_paths_20 AS alternative_paths\nJOIN hospital_rs_node_v2 AS hospitals\nON hospitals.id = alternative_paths.end_vid\nWHERE end_vid = 1743;\n\n\nCREATE TABLE paths_linestring_table AS\nWITH paths_linestring AS (\nSELECT\n\tstart_vid,\n\tend_vid,\n\tpath,\n\tst_union(the_geom) AS line_geom\nFROM \n\tthree_alternative_paths_20\nGROUP BY path, start_vid, end_vid)\nSELECT \n\tpaths_linestring.*,\n\thospitals.ds_cnes,\n\tround(st_length(line_geom::geography)::numeric/1000,2) AS distance\nFROM \n\tpaths_linestring\nJOIN hospital_rs_node_v2 AS hospitals\nON hospitals.id = paths_linestring.end_vid\n\n```\n:::\n\n\n\nThis code created the table to represent these values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalternative_routes <- st_read(eisenberg_connection ,\"paths_linestring_table\")\n\n\nlibrary(gtExtras)\nalternative_routes |> arrange(distance) |> \n      st_drop_geometry() |>\n      select(c(ds_cnes, path, distance)) |> \n      mutate(ds_cnes = as_factor(str_to_title(ds_cnes))) |>\n      group_by(ds_cnes) |> \n      mutate(sd = sd(distance)) |> \n    gt(groupname_col=\"ds_cnes\")  \n```\n:::\n\n\n### Porto Alegre\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n--- Before flooding\nCREATE TABLE centroid_cbd_porto AS\nSELECT \n\tvertices.id,\n\tvertices.the_geom\nFROM \n\tcentral_business_district  AS cbd\nLEFT JOIN LATERAL \n\t(SELECT\n\t\tid,\n\t\tthe_geom\n\t FROM\n\t \tporto_alegre_net_pre_vertices_pgr AS vertices\n\t \tORDER BY \n\t \t\tst_centroid(cbd.st_union) <-> vertices.the_geom\n\t \t\tLIMIT 1) AS vertices ON TRUE\t\nWHERE \n\tnm_bairro \nLIKE\n\t'Centro Histórico';\n\n\nCREATE TABLE first_path_porto_alegre_cbd AS\nSELECT \n        seq,\n        path_seq,\n        start_vid,\n        end_vid,\n        node,\n        edge,\n        net.the_geom,\n        1 AS path\nFROM  pgr_dijkstra('\n                SELECT \n                        id,\n                        source,\n                        target,\n                        cost\n                FROM porto_alegre_net_largest',\n                (SELECT id FROM centroid_cbd_porto),\n                ARRAY(SELECT id FROM hospital_rs_node_v2),\n                directed := TRUE) AS path\n    LEFT JOIN porto_alegre_net_largest AS net\n    ON path.edge = net.id;\n    \n   \nCREATE TABLE dijkstra_second_route_cbd_porto AS\nWITH pgr_doubled_dijkstra AS (\nSELECT \n    *\nFROM  pgr_dijkstra('\n                SELECT \n                        id,\n                        source,\n                        target,\n                        cost\n                FROM porto_alegre_net_largest',\n                 (SELECT id FROM centroid_cbd_porto),\n                ARRAY(SELECT id FROM hospital_rs_node_v2),\n                directed:=true)), \nsecond_route AS (\n            SELECT \n            net.*,\n            CASE \n                WHEN route.node = net.source THEN net.cost * 20\n                ELSE net.cost\n            END AS cost_updated\n            FROM            \n                porto_alegre_net_largest AS net\n            LEFT JOIN \n                pgr_doubled_dijkstra  AS route \n            ON  \n                route.edge= net.id) \n        SELECT * FROM second_route; \n--- Create spatial index   \nCREATE INDEX idx_second_cdb_porto ON dijkstra_second_route_cbd_porto USING gist(the_geom);\nCREATE INDEX idx_second_cdb_porto_source ON dijkstra_second_route_cbd_porto USING btree(source);\nCREATE INDEX idx_second_cdb_porto_target ON dijkstra_second_route_cbd_porto USING btree(target);\n  \n---- obtain the second shortest path, since the first-path has now higher \nDROP TABLE second_path_dikstra_cdb_porto;\nCREATE TABLE second_path_dikstra_cdb_porto AS\nSELECT \n            seq,\n            path_seq,\n            start_vid,\n            end_vid,\n            node,\n            edge,\n            net.the_geom,\n            2 AS path\n        FROM \n            pgr_Dijkstra('\n                    SELECT\n                        id,\n                        source,\n                        target,\n                        cost_updated AS cost\n                    FROM\n                        dijkstra_second_route_cbd_porto',\n                    (SELECT id FROM centroid_cbd_porto),\n                    ARRAY(SELECT id FROM hospital_rs_node_v2))  AS path\n        LEFT JOIN\n                dijkstra_second_route_cbd_porto AS net ON\n            path.edge = net.id;\nselect * from second_path_dikstra_cdb_porto;\n           \nCREATE TABLE dijkstra_third_route_cdb_porto AS\nWITH pgr_doubled_dijkstra AS (\nSELECT \n    *\nFROM  pgr_dijkstra('\n                SELECT \n                        id,\n                        source,\n                        target,\n                        cost_updated AS cost\n                FROM dijkstra_second_route_cbd_porto',\n                (SELECT id FROM centroid_cbd_porto),\n                ARRAY(SELECT id FROM hospital_rs_node_v2),\n                directed:=true)), ----node 9372, network = source, target)\nsecond_route AS (\n            SELECT \n            net.*,\n            CASE \n                WHEN route.node = net.source THEN net.cost_updated * 20\n                ELSE net.cost_updated\n            END AS cost_updated_nd\n            FROM            \n                dijkstra_second_route_cbd_porto AS net\n            LEFT JOIN \n                pgr_doubled_dijkstra  AS route \n            ON  \n                route.edge= net.id) \n        SELECT * FROM second_route;\n    ----\n       \nCREATE TABLE third_path_dikstra_cdb_porto AS\nSELECT \n            seq,\n            path_seq,\n            start_vid,\n            end_vid,\n            node,\n            edge,\n            net.the_geom,\n            3 AS path\n        FROM \n            pgr_Dijkstra('\n                    SELECT\n                        id,\n                        source,\n                        target,\n                        cost_updated_nd AS cost\n                    FROM\n                        dijkstra_third_route_cdb_porto',\n                    (SELECT id FROM centroid_cbd_porto),\n                    ARRAY(SELECT id FROM hospital_rs_node_v2))  AS path\n        LEFT JOIN\n                dijkstra_third_route_cdb_porto AS net ON\n            path.edge = net.id;\n            \n            select * from third_path_dikstra_cdb_porto;    \n\nCREATE TABLE three_alternative_paths_porto AS \nSELECT * FROM first_path_porto_alegre_cbd\nUNION\nSELECT * FROM second_path_dikstra_cdb_porto\nUNION\nSELECT * FROM third_path_dikstra_cdb_porto\n\n\nCREATE TABLE paths_linestring_table_cdb_porto AS\nWITH paths_linestring AS (\nSELECT\n    start_vid,\n    end_vid,\n    path,\n    st_union(the_geom) AS line_geom\nFROM \n    three_alternative_paths_porto\nGROUP BY path, start_vid, end_vid)\nSELECT \n    paths_linestring.*,\n    hospitals.ds_cnes,\n    round(st_length(line_geom::geography)::numeric/1000,2) AS distance\nFROM \n    paths_linestring\nJOIN hospitales AS hospitals\nON hospitals.id = paths_linestring.end_vid\n\n\nSELECT * FROM paths_linestring_table_cdb_porto;\n\n---- after flooding\n    \n ---- Postflooding\n\n---- hospitals\n CREATE TABLE hospitals_after_flooding AS \n SELECT \n \thospitals.id \n FROM \n \thospital_rs_node_v2 AS hospitals,\n\tflooding_cleaned_porto_union AS flood\nWHERE st_disjoint(hospitals.geom_node,\n\t\t\t\tflood.geom);\n\t\n-----\n\t\t\nDROP TABLE first_path_porto_alegre_cbd_after;\nCREATE TABLE first_path_porto_alegre_cbd_after AS\nSELECT \n        seq,\n        path_seq,\n        start_vid,\n        end_vid,\n        node,\n        edge,\n        net.the_geom,\n        1 AS path\nFROM  pgr_dijkstra('\n                SELECT \n                        id,\n                        source,\n                        target,\n                        cost\n                FROM  prueba_largest_network_post',\n                (SELECT id FROM centroid_cbd_porto),\n                ARRAY(SELECT id FROM hospitals_after_flooding),\n                directed := TRUE) AS path\n    LEFT JOIN prueba_largest_network_post AS net\n    ON path.edge = net.id; \n----------------\nDROP TABLE dijkstra_second_route_cbd_porto_after;\nCREATE TABLE dijkstra_second_route_cbd_porto_after AS\nWITH pgr_doubled_dijkstra AS (\nSELECT \n    *\nFROM  pgr_dijkstra('\n                SELECT \n                        id,\n                        source,\n                        target,\n                        cost\n                FROM prueba_largest_network_post',\n                 (SELECT id FROM centroid_cbd_porto),\n                ARRAY(SELECT id FROM hospitals_after_flooding),\n                directed:=true)), \nsecond_route AS (\n            SELECT \n            net.*,\n            CASE \n                WHEN route.node = net.source THEN net.cost * 20\n                ELSE net.cost\n            END AS cost_updated\n            FROM            \n                prueba_largest_network_post AS net\n            LEFT JOIN \n                pgr_doubled_dijkstra  AS route \n            ON  \n                route.edge= net.id) \n        SELECT * FROM second_route; \n-----\n  \nSELECT DISTINCT(end_vid) FROM first_path_porto_alegre_cbd_after; ---15 hospitals\nSELECT DISTINCT (cd_cnes) FROM hospital_rs_node_v2 ; --- 22 hospital totals\n\n-------------\nDROP TABLE second_path_dikstra_cdb_porto_after;\t\nCREATE TABLE second_path_dikstra_cdb_porto_after AS\nSELECT \n            seq,\n            path_seq,\n            start_vid,\n            end_vid,\n            node,\n            edge,\n            net.the_geom,\n            2 AS path\n        FROM \n            pgr_Dijkstra('\n                    SELECT\n                        id,\n                        source,\n                        target,\n                        cost_updated AS cost\n                    FROM\n                        dijkstra_second_route_cbd_porto_after',\n                    (SELECT id FROM centroid_cbd_porto),\n                    ARRAY(SELECT id FROM hospital_rs_node_v2))  AS path\n        LEFT JOIN\n                dijkstra_second_route_cbd_porto_after AS net ON\n            path.edge = net.id;\n           \n\nDROP TABLE dijkstra_third_route_cdb_porto_after;\nCREATE TABLE dijkstra_third_route_cdb_porto_after AS\nWITH pgr_doubled_dijkstra AS (\nSELECT \n    *\nFROM  pgr_dijkstra('\n                SELECT \n                        id,\n                        source,\n                        target,\n                        cost_updated AS cost\n                FROM dijkstra_second_route_cbd_porto_after',\n                (SELECT id FROM centroid_cbd_porto),\n                ARRAY(SELECT id FROM hospital_rs_node_v2),\n                directed:=true)), ----node 9372, network = source, target)\nsecond_route AS (\n            SELECT \n            net.*,\n            CASE \n                WHEN route.node = net.source THEN net.cost_updated * 20\n                ELSE net.cost_updated\n            END AS cost_updated_nd\n            FROM            \n                dijkstra_second_route_cbd_porto_after AS net\n            LEFT JOIN \n                pgr_doubled_dijkstra  AS route \n            ON  \n                route.edge= net.id) \n        SELECT * FROM second_route;\n       \n-----\nDROP TABLE third_path_dikstra_cdb_porto_after;\nCREATE TABLE third_path_dikstra_cdb_porto_after AS\nSELECT \n            seq,\n            path_seq,\n            start_vid,\n            end_vid,\n            node,\n            edge,\n            net.the_geom,\n            3 AS path\n        FROM \n            pgr_Dijkstra('\n                    SELECT\n                        id,\n                        source,\n                        target,\n                        cost_updated_nd AS cost\n                    FROM\n                        dijkstra_third_route_cdb_porto_after',\n                    (SELECT id FROM centroid_cbd_porto),\n                    ARRAY(SELECT id FROM hospital_rs_node_v2))  AS path\n        LEFT JOIN\n                dijkstra_third_route_cdb_porto_after AS net ON\n            path.edge = net.id;\n\n           \nCREATE TABLE three_alternative_paths_porto_after AS \nSELECT * FROM first_path_porto_alegre_cbd_after\nUNION\nSELECT * FROM second_path_dikstra_cdb_porto_after\nUNION\nSELECT * FROM third_path_dikstra_cdb_porto_after\n\n\nCREATE TABLE paths_linestring_table_cdb_porto_after AS\nWITH paths_linestring AS (\nSELECT\n    start_vid,\n    end_vid,\n    path,\n    st_union(the_geom) AS line_geom\nFROM \n    three_alternative_paths_porto_after\nGROUP BY path, start_vid, end_vid)\nSELECT \n    paths_linestring.*,\n    hospitals.ds_cnes,\n    round(st_length(line_geom::geography)::numeric/1000,2) AS distance\nFROM \n    paths_linestring\nJOIN hospital_rs_node_v2 AS hospitals\nON hospitals.id = paths_linestring.end_vid\n\n```\n:::\n\n\n### Canoas\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\n\nCREATE TABLE centroid_cbd_canoas AS\nSELECT \n\tvertices.id,\n\tvertices.the_geom\nFROM \n\tcentral_business_district  AS cbd\nLEFT JOIN LATERAL \n\t(SELECT\n\t\tid,\n\t\tthe_geom\n\t FROM\n\t \tporto_alegre_net_pre_vertices_pgr AS vertices\n\t \tORDER BY \n\t \t\tst_centroid(cbd.st_union) <-> vertices.the_geom\n\t \t\tLIMIT 1) AS vertices ON TRUE\t\nWHERE \n\tnm_bairro \nLIKE\n\t'Centro';\n\n\nCREATE TABLE first_path_canoas_cbd AS\nSELECT \n        seq,\n        path_seq,\n        start_vid,\n        end_vid,\n        node,\n        edge,\n        net.the_geom,\n        1 AS path\nFROM  pgr_dijkstra('\n                SELECT \n                        id,\n                        source,\n                        target,\n                        cost\n                FROM porto_alegre_net_largest',\n                (SELECT id FROM centroid_cbd_canoas),\n                ARRAY(SELECT id FROM hospital_rs_node_v2),\n                directed := TRUE) AS path\n    LEFT JOIN porto_alegre_net_largest AS net\n    ON path.edge = net.id;\n    \n\nCREATE TABLE dijkstra_second_route_cbd_canoas AS\nWITH pgr_doubled_dijkstra AS (\nSELECT \n    *\nFROM  pgr_dijkstra('\n                SELECT \n                        id,\n                        source,\n                        target,\n                        cost\n                FROM porto_alegre_net_largest',\n                 (SELECT id FROM centroid_cbd_canoas),\n                ARRAY(SELECT id FROM hospital_rs_node_v2),\n                directed:=true)), \nsecond_route AS (\n            SELECT \n            net.*,\n            CASE \n                WHEN route.node = net.source THEN net.cost * 20\n                ELSE net.cost\n            END AS cost_updated\n            FROM            \n                porto_alegre_net_largest AS net\n            LEFT JOIN \n                pgr_doubled_dijkstra  AS route \n            ON  \n                route.edge= net.id) \n        SELECT * FROM second_route; \n--- Create spatial index   \nCREATE INDEX idx_second_cdb_porto ON dijkstra_second_route_cbd_porto USING gist(the_geom);\nCREATE INDEX idx_second_cdb_porto_source ON dijkstra_second_route_cbd_porto USING btree(source);\nCREATE INDEX idx_second_cdb_porto_target ON dijkstra_second_route_cbd_porto USING btree(target);\n  \n---- obtain the second shortest path, since the first-path has now higher \n\nCREATE TABLE second_path_dikstra_cdb_canoas AS\nSELECT \n            seq,\n            path_seq,\n            start_vid,\n            end_vid,\n            node,\n            edge,\n            net.the_geom,\n            2 AS path\n        FROM \n            pgr_Dijkstra('\n                    SELECT\n                        id,\n                        source,\n                        target,\n                        cost_updated AS cost\n                    FROM\n                        dijkstra_second_route_cbd_canoas',\n                    (SELECT id FROM centroid_cbd_canoas),\n                    ARRAY(SELECT id FROM hospital_rs_node_v2))  AS path\n        LEFT JOIN\n                dijkstra_second_route_cbd_canoas AS net ON\n            path.edge = net.id;\nselect * from second_path_dikstra_cdb_canoas;\n           \n\n\n\nCREATE TABLE dijkstra_third_route_cdb_canoas AS\nWITH pgr_doubled_dijkstra AS (\nSELECT \n    *\nFROM  pgr_dijkstra('\n                SELECT \n                        id,\n                        source,\n                        target,\n                        cost_updated AS cost\n                FROM dijkstra_second_route_cbd_canoas',\n                (SELECT id FROM centroid_cbd_canoas),\n                ARRAY(SELECT id FROM hospital_rs_node_v2),\n                directed:=true)), ----node 9372, network = source, target)\nsecond_route AS (\n            SELECT \n            net.*,\n            CASE \n                WHEN route.node = net.source THEN net.cost_updated * 20\n                ELSE net.cost_updated\n            END AS cost_updated_nd\n            FROM            \n                dijkstra_second_route_cbd_canoas AS net\n            LEFT JOIN \n                pgr_doubled_dijkstra  AS route \n            ON  \n                route.edge= net.id) \n        SELECT * FROM second_route;\n    ----\n       \nCREATE TABLE third_path_dikstra_cdb_canoas AS\nSELECT \n            seq,\n            path_seq,\n            start_vid,\n            end_vid,\n            node,\n            edge,\n            net.the_geom,\n            3 AS path\n        FROM \n            pgr_Dijkstra('\n                    SELECT\n                        id,\n                        source,\n                        target,\n                        cost_updated_nd AS cost\n                    FROM\n                        dijkstra_third_route_cdb_canoas',\n                    (SELECT id FROM centroid_cbd_canoas),\n                    ARRAY(SELECT id FROM hospital_rs_node_v2))  AS path\n        LEFT JOIN\n                dijkstra_third_route_cdb_canoas AS net ON\n            path.edge = net.id;\n            \n            select * from third_path_dikstra_cdb_canoas;    \n\nCREATE TABLE three_alternative_paths_canoas AS \nSELECT * FROM first_path_canoas_cbd\nUNION\nSELECT * FROM second_path_dikstra_cdb_canoas\nUNION\nSELECT * FROM third_path_dikstra_cdb_canoas\n\n\nCREATE TABLE paths_linestring_table_cdb_canoas AS\nWITH paths_linestring AS (\nSELECT\n    start_vid,\n    end_vid,\n    path,\n    st_union(the_geom) AS line_geom\nFROM \n    three_alternative_paths_canoas\nGROUP BY path, start_vid, end_vid)\nSELECT \n    paths_linestring.*,\n    hospitals.ds_cnes,\n    round(st_length(line_geom::geography)::numeric/1000,2) AS distance\nFROM \n    paths_linestring\nJOIN hospitales AS hospitals\nON hospitals.id = paths_linestring.end_vid\n\n```\n:::\n\n## Visualization\n## Tabla A: alternative\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### alternative routes before\nalternative_routes <- st_read(eisenberg_connection,                         \"paths_linestring_table\")\nalternative_routes$momment <- \"pre\"\n#### alternative routes after\nalternative_routes_after <- st_read(eisenberg_connection,       \"paths_linestring_table_cdb_porto_after\")\nalternative_routes_after$momment <- \"post\"\n\n##### binding the two\nalternative_routes_both <- alternative_routes |> \n  bind_rows(alternative_routes_after)\n#### Creating table for before flooding\ntable_before |> arrange(ds_cnes)  |>  write_csv(\"table_before_sd.csv\")\ntable_before <- alternative_routes |> \n  rename(distance_before = distance) |> \n  arrange(distance_before) |> \n  st_drop_geometry() |>\n  select(c(ds_cnes, path, distance_before)) |> \n  mutate(ds_cnes = as_factor(str_to_title(ds_cnes))) |>\n  group_by(ds_cnes) |> \n  mutate(sd_distance_before = sd(distance_before))\n##### Creating table for after flooding\ntable_after <- alternative_routes_after |> arrange(distance) |> \n  st_drop_geometry() |>\n  rename(distance_after = distance) |> \n  select(c(ds_cnes, path, distance_after)) |> \n  mutate(ds_cnes = as_factor(str_to_title(ds_cnes))) |>\n  group_by(ds_cnes) |> \n  mutate(sd_distance_after = sd(distance_after))\ntable_after |> arrange(ds_cnes)  |> write_csv(\"table_after_sd.csv\")\n\n#### Creating sd table\ntabla_alternative_roads_sd <- alternative_routes_both |>\n  sf::st_drop_geometry() |> \n  mutate(ds_cnes = as_factor(str_to_title(ds_cnes)))  |> \n  pivot_wider(names_from = momment,\n              values_from=distance,\n              names_glue = \"{momment}_distance\") |> \n  group_by(end_vid,ds_cnes) |>\n  summarise(sd_distance_pre = sd(pre_distance, na.rm=TRUE),\n            sd_distance_post = sd(post_distance, na.rm =TRUE)) |>\n  mutate(change_sd = (sd_distance_post-sd_distance_pre)/sd_distance_pre)\n```\n:::\n\n\n## Tabla B: centrality\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n---- bairros\n\nDROP TABLE bairro_porto_cleaned ;\ncreate table bairro_porto_cleaned AS\nselect distinct on (cd_geocodb)\n\t\tcd_geocodb,\n\t\ttipo,\n\t\tnm_bairro,\n\t\tst_union(st_transform(geom,4326)) AS the_geom\nfrom \n\tbarrios_brasil \nwhere nm_bairro IS NOT NULL\nGROUP BY\n\tcd_geocodb, tipo, nm_bairro;\n\n\n---- subdistricts cd_geocods \ncreate table subdistricts_porto_cleaned AS\nselect distinct on (cd_geocods)\n\t\tcd_geocods,\n\t\ttipo,\n\t\tnm_bairro,\n\t\tnm_subdist,\n\t\tst_union(st_transform(geom,4326)) AS the_geom\nfrom \n\tbarrios_brasil \nGROUP BY\n\tcd_geocods, tipo, nm_bairro,nm_subdist;\n---- districts\ncreate table districts_porto_cleaned AS\nselect distinct on (cd_geocodd)\n\t\tcd_geocodd,\n\t\ttipo,\n\t\tnm_distrit,\n\t\tst_union(st_transform(geom,4326)) AS the_geom\nfrom \n\tbarrios_brasil \nGROUP BY\n\tcd_geocodd, tipo, nm_distrit;\n\n---\n\nSELECT * FROM bairro_porto_cleaned;\nSELECT * FROM barrios_brasil;\nSELECT * FROM districts_porto_cleaned;\n----- Municipalities\ncreate table municipalities_porto_cleaned AS\nselect distinct on (cd_geocodm)\n\t\tcd_geocodm,\n\t\ttipo,\n\t\tnm_municip,\n\t\tst_union(st_transform(geom,4326)) AS the_geom\nfrom \n\tbarrios_brasil \nGROUP BY\n\tcd_geocodm, tipo, nm_municip;\n----- centrality para barrios\nCREATE TABLE table_barrios_mean AS\nWITH centrality_barrios AS (\nSELECT \n\tcd_geocodb,\n\tbairros.nm_bairro,\n\tbairros.tipo,\n\tcentrality.*,\n\tbairros.the_geom AS polygon\nFROM \n\tcentrality_weighted_100_bidirect_cleaned AS centrality\t\nLEFT JOIN bairro_porto_cleaned AS bairros\nON st_intersects(centrality.the_geom,\n\t\t\t\t\tbairros.the_geom))\nSELECT \n\tcd_geocodb AS bairro_id,\n\tnm_bairro AS bairro_name,\n\ttipo AS bairro_type,\n\tsum(st_length(the_geom)) AS total_length,\n\tavg(centrality) AS mean_centrality,\n\tpercentile_disc(0.5) WITHIN GROUP (ORDER BY centrality) AS median,\n\tpolygon\nFROM centrality_barrios\t\nWHERE nm_bairro IS NOT NULL\nGROUP BY cd_geocodb, nm_bairro, tipo, polygon\n\n```\n:::\n\n\n\n### Data \n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE centrality_both_sankey  AS\nWITH centrality_both_sankey AS (\nSELECT  centrality_pre.bidirectid,\n        centrality_pre.centrality AS centrality_pre,\n        centrality_post.centrality AS centrality_post,\n        centrality_pre.the_geom AS pre_geom,\n        centrality_post.the_geom AS post_geom\nFROM centrality_weighted_100_bidirect_cleaned AS centrality_pre\nFULL OUTER JOIN centrality_weighted_100_bidirect_cleaned_post AS centrality_post\n  ON centrality_pre.bidirectid = centrality_post.bidirectid)\nSELECT \n    bidirectid,\n    centrality_pre,\n    centrality_post,\n    COALESCE(ST_Length(pre_geom::geography)/100, ST_Length(post_geom::geography)/1000) AS geom_length\nFROM \n    centrality_both_sankey;\n\n```\n:::\n\n\n### plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggsankey)\n\n### Flow Chart\ncentrality_both_sankey <- DBI::dbReadTable(eisenberg_connection, \"centrality_both_sankey\")\n\ndf_centrality_both_sankey <- centrality_both_sankey |> \n  mutate(pre_scenario=\n           as.factor(case_when(\n             centrality_pre == 0 ~ \"[0]\",\n             centrality_pre > 0 & centrality_pre <= 146 ~ \"[1-146]\",\n             centrality_pre >= 146 & centrality_pre <=345 ~ \"[146-345]\",\n             centrality_pre >= 345 & centrality_pre <= 633  ~ \"[345-633]\",\n             centrality_pre >= 633 ~ \"[633-1644]\",\n             TRUE ~ \"[0]\")),\n         post_scenario=\n           as.factor(case_when(\n             centrality_post == 0 ~ \"[0]\",\n             centrality_post > 0 & centrality_post <= 146 ~ \"[1-146]\",\n             centrality_post >= 146 & centrality_post <=345 ~ \"[146-345]\",\n             centrality_post >= 345 & centrality_post <= 633  ~ \"[345-633]\",\n             centrality_post >= 633 ~ \"[633-1644]\",\n             TRUE ~ \"[0]\"))) \n\n# HeiGIt --- Create a long format dataset for ggsankey\ndf_centrality_both_sankey_long <- df_centrality_both_sankey |> \n  mutate(\n    pre_scenario = as.character(pre_scenario),\n    post_scenario = as.character(post_scenario)) |> \n  ggsankey::make_long(5:6) \n\n# Create an initial Sankey diagram (not used in final plot, but used to extract data)\nmycolour <- c(\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\")\nnames(mycolour) <- c(unique(df_centrality_both_sankey_long$node)[3],\n                     unique(df_centrality_both_sankey_long$node)[1],\n                     unique(df_centrality_both_sankey_long$node)[2],\n                     unique(df_centrality_both_sankey_long$node)[4],\n                     unique(df_centrality_both_sankey_long$node)[5])\nauxiliar_data <-df_centrality_both_sankey_long |> group_by(node, x) |> count()\ndf_centrality_both_sankey_long$node <- factor(df_centrality_both_sankey_long$node, levels=c(\"[0]\",\n                                                                                            \"[1-146]\",\n                                                                                            \"[146-345]\",\n                                                                                            \"[345-633]\",\n                                                                                            \"[633-1644]\")) \np <- ggplot(df_centrality_both_sankey_long, aes(x = x,\n                                                next_x = next_x,\n                                                node = node,\n                                                next_node = next_node,\n                                                fill = factor(node),\n                                                label = node)) +\n  geom_sankey(flow.alpha = 0.6) +\n  geom_sankey_text() +\n  scale_fill_manual(values = mycolour) + \n  geom_sankey_label( fill=\"white\", alpha=.7) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    plot.background = element_rect(fill = \"grey99\", color = NA)\n  )\n\n# Extract flow, node, and label data from the Sankey diagram\nmoves_flows <- layer_data(p, 1) %>% \n  mutate(height = flow_end_ymax - flow_end_ymin)\n\nmoves_nodes <- layer_data(p, 2)\n\nmoves_labels <- layer_data(p, 3)\n\nf1 <- \"Graphik\"\nf1b <- \"Graphik Compact\"\nf2 <- \"Publico Headline\"\n\n# Apply factor levels to ensure matching with mycolour\nmoves_nodes$label <- factor(moves_nodes$label, levels = names(mycolour))\nmoves_flows$label <- factor(moves_flows$label, levels = names(mycolour))\n\np1 <- ggplot() +\n  # Add flow polygons, highlighting the most common moves and using the correct fill mapping\n  geom_polygon(data = moves_flows, aes(x, y, group = group, fill = label)) +\n  # Add node rectangles with color based on the label\n  geom_rect(data = moves_nodes, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = \"white\"), fill=\"white\") +\n  # Manually scale the fill using the mycolour palette\n  scale_fill_manual(values = mycolour) +\n  # Add labels for the most common moves\n  geom_text(data = moves_labels,\n            aes(x, y, label = label),\n            family = f1b,\n            color = \"black\",\n            size = 6) +\n  labs(\n    title = \"Changes on Connectivity\",\n    subtitle = \"Porto Alegre Settlement\",\n    caption = \"Source: OpenStreetMap · Graphic: Ricardo Ruiz Sánchez inspired by Georgios Karamanis\"\n  ) +\n  theme_void(base_family = f1) +\n  theme(\n    legend.position = \"none\",\n    plot.background = element_rect(fill = \"white\", color = NA),\n    plot.margin = margin(10, 10, 10, 10),\n    plot.title = element_text(size = 30, face = \"bold\", family = f2),\n    plot.subtitle = element_text(size = 15, lineheight = 1, color = \"#676162\"),\n    plot.caption = element_text(hjust = 0, size = 12, \"#676162\")\n  )\n\nggsave(\"plot_flow_chart.jpg\", plot= p1, dpi= 300, width= 10, height= 15)\n\n## Length roads\n### pre-length\ndf_length_pre <- centrality_both_sankey |> select(bidirectid, centrality_pre, geom_length) |>\n  rename(centrality = centrality_pre) |> \n  mutate(\n  category_centrality=\n    as.factor(case_when(\n      centrality == 0 ~ \"[0]\",\n      centrality > 0 & centrality <= 146 ~ \"[1-146]\",\n      centrality >= 146 & centrality <=345 ~ \"[146-345]\",\n      centrality >= 345 & centrality <= 633  ~ \"[345-633]\",\n      centrality >= 633 ~ \"[633-1644]\",\n      TRUE ~ \"[0]\"))) |> \n  dplyr::select(c(geom_length, category_centrality)) |> \n  group_by(category_centrality) |>\n  summarise(total_lenth=sum(geom_length))\ndf_length_pre$event <- \"Road length (%)\"\ndf_length_pre$pct <- as.numeric(round(df_length_pre$total_lenth/(sum(df_length_pre$total_lenth)),4))\n\n## pre-length-plot\nggplot(df_length_pre, aes(x = event, y = pct, fill = category_centrality)) +\n  geom_col() +\n  coord_flip() +\n  scale_fill_manual(values = mycolour) +\n  #theme_minimal() +\n  ggthemes::theme_clean() +\n  labs(x=\"\", y=\"\") +\n  theme(\n    legend.position = \"none\",\n    legend.text = element_text(size = 7),\n    legend.title = element_text(size = 7),\n    legend.background = element_blank(),\n    plot.background = element_blank(),\n    plot.caption = element_text(face = \"italic\",\n                                size = 8,\n                                color = \"grey30\"\n    )\n  ) +\n  guides (\n    fill = guide_legend(nrow =2, byrow = TRUE)\n  ) \n\n## Centralities values\ndf_barplots_sankey <- df_centrality_both_sankey |>\n  pivot_longer(cols=c(\"post_scenario\",\"pre_scenario\"),\n               names_to =\"event\",\n               values_to = \"quartile\")\ncentrality_both_longer <- centrality_both |> pivot_longer(cols=c(pre_scenario, post_scenario),\n                                names_to = \"quartile\",\n                                values_to = \"category\") \ndf_barplots_sankey <- centrality_both_longer |> \n  dplyr::select(c(centrality, quartile, category)) |>\n  group_by(quartile, category) |> summarise(centrality=sum(centrality)) |>\n  mutate(total_perc = centrality/sum(centrality))\n\nggplot(df_barplots_sankey, aes(x = quartile, y = total_perc, fill = category)) +\n  geom_col() +\n  scale_x_discrete(labels=c(\"centrality_post\" = \"Post-flooding\", \"centrality_pre\" = \"Pre-flooding\")) +\n  coord_flip() +\n  scale_fill_manual(values = mycolour) +\n  labs(\n    x = \"Event\",\n    y = \"Centrality (%)\",\n    title = \"Share of centrality per range in the two scenarios\"\n  ) +\n  #theme_minimal() +\n  ggthemes::theme_clean() +\n  theme(\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 7),\n    legend.title = element_text(size = 7),\n    legend.background = element_blank(),\n    plot.background = element_blank(),\n    plot.caption = element_text(face = \"italic\",\n                                size = 8,\n                                color = \"grey30\"\n    )\n  ) +\n  guides (\n    fill = guide_legend(nrow = 1, byrow = TRUE)\n  ) \n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}