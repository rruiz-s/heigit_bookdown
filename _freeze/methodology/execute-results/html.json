{
  "hash": "e31e886f8c769b429a9340d39a306c45",
  "result": {
    "markdown": "::: {.cell}\n\n:::\n\n\n# Methodology\n## Data\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-e13582b57062afc14b5c\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-e13582b57062afc14b5c\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"caption\":\"<caption>Data description<\\/caption>\",\"data\":[[\"flooding_rio_grande_do_sul.geojson\",\"sul-240501.osm.pbf\",\"nuts.geojson\",\"urban_center_4326.geojson\",\"Ghs-built-v\"],[\"Flood hazard maps\",\"Road network\",\"Administrative units\",\"Urban classification\",\"Building density\"],[2024,2024,2024,2020,2020],[\"Database of floods in the Guaiba Lake Hydrographic Region in May 2024\",\"Street Network from Brazil-Sul\",\"Subnational Administratives Boundaries\",\"Global Human Settlement Layer -SMOD\",\"Global Human Settlement built-up volume\"],[\"<a href=\\\"https://zenodo.org/records/12593168\\\">Link <\\/a>\",\"<a href=\\\"https://download.geofabrik.de/south-america/brazil/sul.html#\\\">Link <\\/a>\",\"<a href=\\\"https://data.humdata.org/dataset/geoboundaries-admin-boundaries-for-brazil\\\">Link <\\/a>\",\"<a href=\\\"https://human-settlement.emergency.copernicus.eu/download.php?ds=smod\\\">Link <\\/a>\",\"<a href=\\\"https://human-settlement.emergency.copernicus.eu/download.php?ds=builtV\\\">Link <\\/a>\"]],\"container\":\"<table class=\\\"compact\\\">\\n  <thead>\\n    <tr>\\n      <th>File<\\/th>\\n      <th>Data Type<\\/th>\\n      <th>Year<\\/th>\\n      <th>Description<\\/th>\\n      <th>Link<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":2},{\"name\":\"File\",\"targets\":0},{\"name\":\"Data Type\",\"targets\":1},{\"name\":\"Year\",\"targets\":2},{\"name\":\"Description\",\"targets\":3},{\"name\":\"Link\",\"targets\":4}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n## Framework\n\n![](/media/workflow_methodology.png)\n\n## Area of Interest\n### Import\n#### Network: OpenStreetMap (OSM)\n\nThe following SQL code created the command to import OpenStreetMap (OSM) network using osmium. Firstly using the [GHS-SMOD dataset](https://human-settlement.emergency.copernicus.eu/download.php?ds=smod) the Global Human Settlement in Porto Alegre is chosen. Secondly, this GHS selected is used to create the bounding box that it is lastly used to generate the osmium code. The OSM network obtained with this osmium command was the input required for OpenRouteService ([ORS](https://heigit.org/introducing-openrouteservice-version-8-0-a-dedication-to-wilfried-juling/)). \n\n\n::: {.cell}\n\n```{#lst-ghs-osmium .sql .cell-code  caption=\"Osmium query generation\"}\n--- GHS urban area that intersected with Porto Alegre city\nWITH porto_alegre_ghs AS(\n\tSELECT \n\t   ghs.*\n\tFROM\n\t   urban_center_4326 AS ghs\n\tJOIN\n\t   nuts \n\tON \n\t   st_intersects(nuts.geom, ghs.geom)\n\tWHERE \n\t\tnuts.shapename = 'Porto Alegre'),\n--- Bounding Box that contained the GHS in Porto Alegre\nporto_alegre_ghs_bbox AS(\n\tSELECT \n\t\tst_setsrid(st_extent(geom),4326) as geom_bbox\n\tFROM \n\t\tporto_alegre_ghs),\n--- The command used the Porto Alegre GHS and its Bounding Box to import the OpenStreet Network. \nporto_alegre_ghs_bbox_osmium_command AS\t(\n\tSELECT \n\t\tST_XMin(ST_SnapToGrid(geom_bbox, 0.0001)) AS min_lon,\n\t\tSt_xmax(ST_SnapToGrid(geom_bbox,0.0001)) AS max_lon,\n\t\tSt_ymin(ST_SnapToGrid(geom_bbox,0.0001)) AS min_lat,\n\t\tSt_ymax(ST_SnapToGrid(geom_bbox, 0.0001)) AS max_lat\n\tFROM porto_alegre_ghs_bbox)\nSELECT\n    'osmium extract -b ' \n\t|| min_lon || ',' || min_lat || ',' || max_lon || ',' || max_lat || \n    ' sul-240501.osm.pbf -o puerto_alegre_urban_center.osm.pbf' AS osmium_command\nFROM porto_alegre_ghs_bbox_osmium_command;\n\n```\n:::\n\n\n\n#### Graph: OpenRouteService (OSM)\n\nA [docker for OpenRouteService](https://giscience.github.io/openrouteservice/run-instance/running-with-docker) transformed the OSM network that covered the GHS in Porto Alegre into a graph. In the \"ors-config.yml\" from OpenRotueService (ORS), the \"source_file\" parameter is set with the following directory.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource_file: /home/ors/files/puerto_alegre_urban_center.osm.pbf\n```\n:::\n\n\nOpenRouteService (ORS) created a a routable network, assigining costs and adding information for each node, namely, \"fromId\" and \"toId\". The network named as \"porto_alegre_net\" extracted from ORS was created using the R script \"get_graph\" from Marcel Reinmuth.\n\n### Cleaning\n\nThe parameters start_vid, end_vid named \"fromid\" and \"toid\" in the network dataset from openrouteservice are transform into bigint data type to run the algorithm pgr_dijkstra as the [official documentation](https://docs.pgrouting.org/latest/en/pgr_dijkstra.html) indicates.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect * from porto_alegre_net_pre; \nALTER TABLE porto_alegre_net_pre \n\tALTER COLUMN \"toid\" type bigint,\n\tALTER COLUMN \"fromid\" type bigint,\n\tALTER COLUMN \"ogc_fid\" type bigint;\n```\n:::\n\n#### Graph\n\nBefore using the graph, a quick inspection of the graph using the pgrouting function [*pgr_strongComponents()*](https://docs.pgrouting.org/dev/en/pgr_strongComponents.html) revealed how many components or isolated self-connecting network the graph had. \n\n\n::: {.cell}\n\n```{.sql .cell-code}\n--- Create a vertice table for pgr_dijkstra()\nSELECT \n  pgr_createVerticesTable('porto_alegre_net_pre');\n  \n---- Add data to the vertices created table \nSELECT pgr_analyzegraph('porto_alegre_net_pre',\n                        0.001); \n------ Analyze components of the graph\nCREATE TABLE component_analysis_network_porto AS\nWITH porto_alegre_net_component AS (\nSELECT \n  * \nFROM \n  pgr_strongComponents('SELECT id,\n                               fromid AS source,\n                               toid AS target,\n                               weight AS cost \n                        FROM \n                              porto_alegre_net_pre')),\nporto_alegre_net_component_geom AS (\nSELECT \n\tnet.*,\n\tnet_geom.the_geom\nFROM \n\tporto_alegre_net_component AS net\nJOIN \n\tporto_alegre_net_pre  AS net_geom\nON \n\tnet.node = net_geom.source)\nSELECT \n\tcomponent,\n\tst_union(the_geom) AS the_geom,\n\tst_length(st_union(the_geom)::geography) AS length\nFROM  \n\tporto_alegre_net_component_geom\nGROUP BY component\nORDER BY distance DESC;\n\n```\n:::\n\n\nThe largest length selected the network component of the study. The following code created this table ruling out the rest of the relatively small networks.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE porto_alegre_net_largest AS\n---- Obtain again table classifying nodes in different components\t\t    \nWITH porto_alegre_net_component AS (\nSELECT \n  * \nFROM \n  pgr_strongComponents('SELECT id,\n                               source,\n                               target,\n                               cost \n                        FROM \n                              porto_alegre_net_pre')),\n--- Calculate the largest component from the network\nlargest_component_net AS (\n\tSELECT \n\t\tcomponent\n\tFROM \n\t \tcomponent_analysis_network_porto \n\tLIMIT 1),\n--- Using the largest component from the network to filter\nlargeset_component_network_porto AS (\nSELECT\n\t*  \nFROM\n\tporto_alegre_net_component,\n\tlargest_component_net\nWHERE \n\tporto_alegre_net_component.component = largest_component_net.component)\nSELECT \n\tnet_multi_component.*\nFROM \n\tporto_alegre_net_pre AS net_multi_component,\n\tlargeset_component_network_porto AS net_largest_component\nWHERE  \n\tnet_multi_component.source IN (net_largest_component.node);\n```\n:::\n\n\n#### Flooding mask\n\nThe downloaded flooding extent covered a larger area in Rio Grande do Sul. However, our area of interest for urban dense city was only Porto Alegre. Therefore, a serie of operations reduced the area focusing on Porto Alegre and at the same time improved the performance reducing the size of the mask.\n\nSubdividing the flooding mask to make the spatial indexes more efficient was the first step. The reason was the higher number of vertices of large objects and larges bounding boxes that hinder the spatial index performance ([Link](https://blog.cleverelephant.ca/2019/11/subdivide.html)). After the spatial indexes were enable, the intersection with the Porto Alegre region subset the data.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n--- Select the GHS area that intersects with Porto Alegre\nCREATE TABLE flooding_subdivided_porto AS\nWITH porto_alegre_ghs AS(\n    SELECT \n       ghs.*\n    FROM\n       urban_center_4326 AS ghs\n    JOIN\n       nuts \n    ON \n       st_intersects(nuts.geom, ghs.geom)\n    WHERE \n        nuts.shapename = 'Porto Alegre'),\n--- Bounding Box that contained the GHS in Porto Alegre\nporto_alegre_ghs_bbox AS(\n    SELECT \n        st_setsrid(st_extent(geom),4326) as geom_bbox\n    FROM \n        porto_alegre_ghs),\n---Subdivide the flood extent to increase spatial indexes performance \nflooding_sul_subdivided AS (\n\t\tSELECT \n\t\t\tst_subdivide(geom) as the_geom\n\t\tFROM\n\t\t\tflooding_rio_grande_do_sul)\t\n---- Select the flooding subunits that intersects with the previous bounding box\nSELECT \n\tflooding_sul_subdivided.* \nFROM \n\tflooding_sul_subdivided, \n\tporto_alegre_ghs_bbox\nWHERE \n\tst_intersects(flooding_sul_subdivided.the_geom, porto_alegre_ghs_bbox.geom_bbox);\n```\n:::\n\n\nAdditionally, the following code dissolve the borders to break the multipolygon into simple polygons to improve the performance of functions such as st_difference() ([link](https://icarto.es/en/improve-performance-making-the-difference-between-two-layers-with-postgis/)).\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE flooding_cleaned_porto AS\n    SELECT (ST_Dump(the_geom)).geom::geometry(polygon, 4326) geom FROM flooding_subdivided_porto;\n    \nCREATE TABLE flooding_cleaned_porto_union AS\n    SELECT ST_Union(geom)::geometry(multipolygon, 4326) geom FROM flooding_cleaned_porto;\n    \nCREATE TABLE flooding_cleaned_porto_union_simple AS\n    SELECT (ST_Dump(geom)).geom::geometry(polygon, 4326) geom FROM flooding_cleaned_porto_union;\n    \nSELECT COUNT(*)\n     FROM flooding_cleaned_porto_union_simple ; --- count= 54.\n\nDELETE FROM flooding_cleaned_porto_union_simple WHERE ST_Area(geom) < 0.0001; ---count= 2.\n\n```\n:::\n\n\n\nThis allowed to calculate the area of each polygon finding slivers that were removed using the following code. \n\n### Transform\n\nThe creation of the network after the disaster using the modified flooding mask and the creation of the origin-destination are considered in this section. The following code set the paremeters before carrying out these transformations following [post 1](https://blog.cleverelephant.ca/2019/05/parallel-postgis-4.html) and [post2](https://gis-ops.com/pgrouting-speedups/).\n\nFirstly, add spatial index everywhere:\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE INDEX idx_porto_alegre_net_largest_geom ON porto_alegre_net_largest USING gist(the_geom);\nCREATE INDEX idx_porto_alegre_net_largest_source ON porto_alegre_net_largest USING btree(source);\nCREATE INDEX idx_porto_alegre_net_largest_target ON porto_alegre_net_largest USING btree(target);\nCREATE INDEX idx_porto_alegre_net_largest_id ON porto_alegre_net_largest USING btree(id);\nCREATE INDEX idx_porto_alegre_net_largest_cost ON porto_alegre_net_largest USING btree(cost);\nCLUSTER porto_alegre_net_largest USING idx_porto_alegre_net_largest_geom;\n```\n:::\n\n::: {.cell}\n\n```{.sql .cell-code}\nSET max_parallel_workers_per_gather =4;\n```\n:::\n\n::: {.cell}\n\n```{.sql .cell-code}\nCLUSTER porto_alegre_net_largest USING porto_alegre_net_largest;\n```\n:::\n\n\n#### Network after the disaster\n\nA naive approach overlaying the flooding mask with the road network by the function *st_difference()* caused the crashing of the session.  The follwing multi-step methodology reduced the processing cost make the query feasible using less resources.\n\n1. Network inside the flooding mask\n2. Network outside the flooding mask\n3. Network on the boundaries\n4. Applying st_difference\n5. Uniting network external to the boundaries and network from outside\n\n1.The network contained by the flooding extent and its intersection is selected.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n------------- network inside\nCREATE TABLE porto_alegre_street_in_v2 AS\nSELECT net.id,\n\tCASE \n\t\tWHEN ST_Contains(flood.the_geom, net.the_geom)\n\t\tTHEN net.the_geom\n\t\tELSE st_intersection(net.the_geom, flood.the_geom)\n\tEND AS  geom\nFROM porto_alegre_net_largest net\nJOIN flooding_subdivided_porto flood\nON st_intersects(net.the_geom, flood.the_geom);\n\n```\n:::\n\n\n2. Instead of using columns containing geometrical variables, the numerical ID is used. For this the previous step, which created a table with the network inside the flooding mask was required.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n----------------- network outside\nCREATE TABLE porto_alegre_street_out_v2 AS\nSELECT net.*\nFROM porto_alegre_net_largest net\nWHERE net.id NOT IN (\n\tSELECT net.id\n\tFROM porto_alegre_street_in_v2 net);\n\n```\n:::\n\n\n3. The function St_ExteriorRing() casted the geometry into linestring reducing the processing costs. This exterior ring selected the road segments located on the boundaries.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE porto_alegre_net_outside_v2 AS\nWITH porto_alegre_ghs AS(\n\tSELECT \n\t   ghs.*\n\tFROM\n\t   urban_center_4326 AS ghs\n\tJOIN\n\t   nuts \n\tON \n\t   st_intersects(nuts.geom, ghs.geom)\n\tWHERE \n\t\tnuts.shapename = 'Porto Alegre'),\n--- Bounding Box that contained the GHS in Porto Alegre\nporto_alegre_ghs_bbox AS(\n\tSELECT \n\t\tst_setsrid(st_extent(geom),4326) as geom_bbox\n\tFROM \n\t\tporto_alegre_ghs),\nflooding_sul_subdivided AS (\n\t\tSELECT \n\t\t\tst_subdivide(geom) as the_geom\n\t\tFROM\n\t\t\tflooding_rio_grande_do_sul),\nexterior_ring_porto_alegre_v2 AS (\nSELECT \n    ST_ExteriorRing((ST_Dump(union_geom)).geom) as geom\nFROM (\n    SELECT \n        ST_Union(flood.the_geom) as union_geom\n    FROM \n        porto_alegre_ghs_bbox as bbox\n    JOIN \n        flooding_sul_subdivided as flood\n    ON \n        ST_Intersects(flood.the_geom, bbox.geom_bbox)\n) AS subquery)\nSELECT net.id,\n \tCASE\n\t\tWHEN NOT ST_Contains(flood.geom, net.the_geom)\n \t\tTHEN net.the_geom\n\t\t\tELSE st_intersection(net.the_geom, flood.geom)\n\tEND AS  geom,\n\tnet.target,\n\t   net.source,\n\t   cost,\n\t   \"unidirectid\",\n\t   \"bidirectid\"\nFROM\nporto_alegre_net_largest AS net\nJOIN exterior_ring_porto_alegre_v2 flood ON\nst_intersects(net.the_geom, flood.geom);\n\n```\n:::\n\n\n4. \n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n--- For the network\nCREATE INDEX idx_porto_alegre_net_outside_v2 ON porto_alegre_net_outside_v2 USING gist (geom);\n\nCLUSTER porto_alegre_net_outside_v2 USING idx_porto_alegre_net_outside_v2;\n\n--- For the flooding mask\nCREATE INDEX flooding_sul_subdivided_idx ON flooding_sul_subdivided USING gist (the_geom);\n\nCLUSTER flooding_sul_subdivided USING flooding_sul_subdivided_idx;\n\n---- Before doing difference\nVACUUM(FULL, ANALYZE) porto_alegre_net_outside_v2;\nVACUUM(FULL, ANALYZE) flooding_sul_subdivided;\n```\n:::\n\n\nLastly, the difference is created using:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE flooding_symple as \nSELECT st_union(geom) as the_geom FROM flooding_cleaned_porto_union_simple;\n\nCREATE INDEX flooding_symple_idx ON flooding_symple USING gist (the_geom);\nCLUSTER flooding_symple USING flooding_symple_idx;\n\nCREATE TABLE difference_outside_flood_v3 AS\nSELECT net.id,\n\t\ttarget,\n\t\tsource,\n\t\tcost,\n\t\tunidirectid,\n\t\tbidirectid,\nst_difference(net.geom, flood.the_geom) AS the_geom\nFROM porto_alegre_net_outside_v2 AS net,\nflooding_symple  AS flood;\n```\n:::\n\n\nAs a final step, they are merged.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n-----------\nCREATE TABLE porto_alegre_street_united AS\nSELECT *\nFROM porto_alegre_street_out\nUNION\nSELECT *\nFROM difference_outside_flood_v2;\n\n```\n:::\n\n\n\n## Routable network\n\n## Centrality Analysis\n\n### Origin-Destination\n\n#### Random distribution (naive)\n\nA series of regular points that represented the origin and destination on the Area of Interest is created with the function  [\"I_Grid_Point_Series\"](https://gis.stackexchange.com/questions/4663/creating-regular-point-grid-inside-polygon-in-postgis).\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n--- Creating sampel data:\nCREATE OR REPLACE FUNCTION I_Grid_Point_Series(geom geometry, x_side decimal, y_side decimal, spheroid boolean default false)\nRETURNS SETOF geometry AS $BODY$\nDECLARE\nx_max decimal;\ny_max decimal;\nx_min decimal;\ny_min decimal;\nsrid integer := 4326;\ninput_srid integer;\nx_series DECIMAL;\ny_series DECIMAL;\nBEGIN\nCASE st_srid(geom) WHEN 0 THEN\n  geom := ST_SetSRID(geom, srid);\n  RAISE NOTICE 'SRID Not Found.';\n    ELSE\n        RAISE NOTICE 'SRID Found.';\n    END CASE;\n\n    CASE spheroid WHEN false THEN\n        RAISE NOTICE 'Spheroid False';\n    else\n        srid := 900913;\n        RAISE NOTICE 'Spheroid True';\n    END CASE;\n    input_srid:=st_srid(geom);\n    geom := st_transform(geom, srid);\n    x_max := ST_XMax(geom);\n    y_max := ST_YMax(geom);\n    x_min := ST_XMin(geom);\n    y_min := ST_YMin(geom);\n    x_series := CEIL ( @( x_max - x_min ) / x_side);\n    y_series := CEIL ( @( y_max - y_min ) / y_side );\nRETURN QUERY\nSELECT st_collect(st_setsrid(ST_MakePoint(x * x_side + x_min, y*y_side + y_min), srid)) FROM\ngenerate_series(0, x_series) as x,\ngenerate_series(0, y_series) as y\nWHERE st_intersects(st_setsrid(ST_MakePoint(x*x_side + x_min, y*y_side + y_min), srid), geom);\nEND;\n$BODY$ LANGUAGE plpgsql IMMUTABLE STRICT;\n\n```\n:::\n\n\nThe following code created 1258 points representing the origin or destination regularly separated by 0.01ยบ.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE regular_point_od AS (\nWITH multipoint_regular AS(\nselect \n\tI_Grid_Point_Series(geom, 0.01,0.01, false) AS geom\n\tfrom porto_alegre_bbox as geom),\npoint_regular AS(\nSELECT \n\tst_setsrid((st_dump(geom)).geom, 4326)::geometry(Point, 4326) AS geom\nFROM  multipoint_regular)\nSELECT \n\trow_number() over() AS id,\n\tgeom\nFROM \n\tpoint_regular);\n```\n:::\n\n\nThe application of two indexes improved further queries on this new table. This was recommended because these points were outside the network requiring snapping, which is a spatial operation with relatively high computational costs. \n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE INDEX idx_regular_point_od_geom ON regular_point_od USING GIST (geom);\nCREATE INDEX idx_regular_point_od_id ON regular_point_od USING btree(id);\n```\n:::\n\n\nApart from indexing the geometry column and the id, the query is constrained to a buffer of 0.02ยบ to reduce computational costs.\n\n\n#### Weighted on building volume\n\n#### Hospitals\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE hospital_rs_node_v2 AS\nWITH hospital_rs_porto AS (\nSELECT \n \th.*\nFROM \n\thospitals_bed_rs AS h,\n\tporto_alegre_bbox bbox\nWHERE st_intersects(h.geom, bbox.geom))\nSELECT DISTINCT ON (h.cd_cnes)\n\tcd_cnes,\n\tds_cnes,\n\tf.id,\n\tf.the_geom <-> h.geom AS distance,\n\th.geom AS geom_hospital,\n\tf.the_geom AS geom_node\nFROM hospital_rs_porto h\nLEFT JOIN LATERAL\n(SELECT \n\tid, \n\tthe_geom\nFROM porto_alegre_net_largest_vertices_pgr AS net\nORDER BY\n\tnet.the_geom <-> h.geom\nLIMIT 1) AS f ON true\n\n---- Create index to optimize fuerther queries\n\nCREATE INDEX idx_hospital_rs_node_v2 ON hospital_rs_node_v2 USING btree(id);\n```\n:::\n\n\n\n### Centrality Analysis: \n\n#### Edge betweenness\n\n#### Closeness\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE clossness_hospital_porto AS \nWITH dijkstra_cost AS (\nSELECT * FROM pgr_dijkstraCostMatrix(\n  'SELECT id, source, target, cost FROM porto_alegre_net_largest',\n  (SELECT array_agg(id)\n    FROM porto_alegre_net_largest_vertices_pgr\n    WHERE id IN (SELECT id FROM hospital_rs_node_v3)),\n  true)),\ncloseness AS (\n SELECT dc.start_vid,\n\t\tsum(agg_cost)::int AS closeness\nFROM dijkstra_cost dc\nGROUP BY dc.start_vid\nORDER BY closeness DESC)\nSELECT \n\th.cd_cnes,\n\th.ds_cnes,\n\tc.closeness,\n\th.distance,\n\th.geom_node,\n\th.geom_hospital\nFROM \n\tcloseness AS c\nLEFT JOIN\n\thospital_rs_node_v3 AS h ON  c.start_vid = h.id;\n```\n:::\n\n\n#### Vulnerability: Socioeconomic indicators\n\n#### Resiliance:\n\n\n",
    "supporting": [
      "methodology_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/datatables-binding-0.33/datatables.js\"></script>\n<script src=\"site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}