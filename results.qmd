# Results

```{r}
#| echo: false
#| output: false
#| warning: false

# Load packages
lapply(c("tidyverse","DT","leaflet","sf","DBI", "RPostgres","dplyr", "mapview","leafpop","leaflet","terra","raster","stars", "lwgeom"),
       require,
       character.only =T)

# Connect to the server
eisenberg_connection <- DBI::dbConnect(RPostgres::Postgres(),
                          user= "docker",
                          password = "docker",
                          host = "localhost",
                          dbname="gis",
                          port = 25432)
```

## Data preparation
### OSM & ORS data

The code @lst-ghs-osmium covered the following area:

```{r}
#| eval: false
# Osmium command
osmium extract -b -51.2791,-30.1722,-50.9407,-29.8048 sul-240501.osm.pbf -o puerto_alegre_urban_center.osm.pbf
```

![](/media/bbox_porto_alegre_ghs.png){fig-align="center" width="50%"}
Importing the geometries from R from Marcel

```{r}
#| eval: false

# Load data
ors_network <- st_read(eisenberg_connection, layer="porto_alegre_net_pre")
osm_network <- st_read(eisenberg_connection, layer="puerto_alegre_ghs_osm")
ors_network_subset <- ors_network |> head()
## Create subset using a bounding box
ors_subset <- ors_network |> filter(id ==140210) |> st_bbox()
xrange <- ors_subset$xmax - ors_subset$xmin
yrange <- ors_subset$ymax - ors_subset$ymin
## Expand the bounding box
ors_subset[1] <- ors_subset[1] - (4 * xrange) # xmin - left
ors_subset[3] <- ors_subset[3] + (4 * xrange) # xmax - right
ors_subset[2] <- ors_subset[2] - (2 * yrange) # ymin - bottom
ors_subset[4] <- ors_subset[4] + (2 * yrange) # ymax - top
## Convert bounding box into polygon
ors_subset_bbox <- ors_subset %>%  # 
  st_as_sfc() 
## Use the polygon to subset the network
intersection_ors <- sf::st_intersection(ors_network, ors_subset_bbox)
intersection_osm <- sf::st_intersection(osm_network, ors_subset_bbox)
## Mapview maps
m1 <- mapview(intersection_osm, 
              color="#6e93ff",
              layer.name ="OpenStreetMap - Geometry",
              popup=popupTable(intersection_osm, 
                               zcol=c("id","osm_id","name","geom")))
m2 <- mapview(intersection_ors,
              color ="#d50038",
              layer.name="OpenRouteService -Graph",
              popup=popupTable(intersection_ors))

sync(m1,m2) 
```


```{sql}
#| connection: eisenberg_connection
#| eval: false

mapview::mapview(top_5_network,
                zcol="component",
                lwd=.5,
                popup=popupTable(top_5_network,
                                 zcol=c("component","distance")))
```

### Sampling points

```{r}

# Crop and Reproject
# gdalwarp -te -4850853.201784615 -3737074.296348413 -4616291.881935796 -3495378.804761388 GHS_BUILT_V_E2020_GLOBE_R2023A_54009_100_V1_0.tif GHS_BUILT_V_E2020_GLOBE_R2023A_54009_100_V
# gdalwarp -t_srs "EPSG:4326" GHS_BUILT_V_E2020_GLOBE_R2023A_54009_100_V1_0_RioGrandeDoSul.tif GHS_BUILT_V_E2020_GLOBE_R2023A_4326_100_V1_0_RioGrandeDoSul.tif
pal <- mapview::mapviewPalette("mapviewTopoColors")
ghs_build <- stack("/home/ricardo/heigit_bookdown/data/GHS_BUILT_V_E2020_GLOBE_R2023A_4326_100_V1_0_RioGrandeDoSul.tif") 
ghs_smod <- stack("/home/ricardo/heigit_bookdown/data/GHS_SMOD_E2020_GLOBE_R2023A_4326_1000_V2_0_RioGrandeDoSul.tif")
ghs_smod_terra <- terra::rast("/home/ricardo/heigit_bookdown/data/GHS_SMOD_E2020_GLOBE_R2023A_4326_1000_V2_0_RioGrandeDoSul.tif")
regular_sampling <- st_read("/home/ricardo/heigit_bookdown/data/random_points_snapped.geojson")
weighted_sampling_origin <- st_read(eisenberg_connection,"weight_sampling_100_origin")
weighted_sampling_destination <- st_read(eisenberg_connection,"weight_sampling_100_destination")
m <- matrix(c(
     0, 10, NA,   # Values >= 0 and <= 10 become 0
     10, 13, 1,  # Values > 10 and <= 21 become 1
     13, 29, 2,  # Values > 21 and <= 29 become 2
     30, 30, 3   # Values == 30 become 3
 ), ncol = 3, byrow = TRUE)
 
# Classify using the correct matrix
rc2 <- classify(ghs_smod_terra, m, include.lowest=TRUE)
rc2_factor <- as.factor(rc2)
levels(rc2_factor) <- data.frame(
  ID = 1:3,    # These should match the values in the classification
  category = c("Rural: 10-13", "Suburban: 13-29", "Urban Center: 30")
)
category_colors <- c("#008f44","#dedb96", "#cc9152")
# mapview(rc2_factor, 
#        na.color="transparent",
#        col.regions = category_colors,  # Apply colors to categories
#        legend = TRUE,                  # Show legend
#        layer.name = "Settlement Typologies")

mapview(ghs_build[[1]],layer.name ="Built-up volume", col.regions = pal(100), legend = TRUE, alpha.regions= 0.35, hide=FALSE) +
mapview(ghs_smod[[1]], layer.name = "Settlement classification", col.regions = pal(100), legend = TRUE, alpha.regions= 0.35, hide=TRUE) +
mapview(weighted_sampling_origin, layer.name="" ,color="blue",col.regions = "blue", hide=FALSE) +
mapview(weighted_sampling_destination, color="red",col.regions = "red", hide=FALSE)  +
mapview(regular_sampling, color = "darkgray", col.regions="darkgray", hide=TRUE) 

```

### Network
#### Post-event

```{sql}
#| connection: eisenberg_connection
#| eval: false

--- pre_net_subset
CREATE TABLE porto_alegre_net_largest_subset AS                  
SELECT
  *
FROM 
  porto_alegre_net_largest AS net
WHERE 
net.the_geom && 
st_setsrid(
            st_makeenvelope(
              -51.214287,-30.020226,-51.12934,-29.945862),4326)
--- subset_network_in

------------- network inside

CREATE TEMPORARY TABLE flooding_subdivided_porto_join AS
SELECT st_union(the_geom) AS the_geom FROM flooding_subdivided_porto ;

----
CREATE TABLE porto_alegre_street_in_v3 AS
SELECT net.id,
    CASE 
        WHEN ST_Contains(flood.the_geom, net.the_geom)
        THEN net.the_geom
        ELSE st_intersection(net.the_geom, flood.the_geom)
    END AS  geom
FROM porto_alegre_net_largest_subset net
JOIN flooding_subdivided_porto_join flood
ON st_intersects(net.the_geom, flood.the_geom);         

--- subset_network_out
CREATE TABLE porto_alegre_street_out_v3 AS
SELECT net.*
FROM porto_alegre_net_largest_subset
WHERE net.id NOT IN (
    SELECT net.id
    FROM porto_alegre_street_in_v3 net);
    
---- network outside

CREATE TABLE porto_alegre_net_outside_v3 AS
WITH porto_alegre_ghs AS(
    SELECT 
       ghs.*
    FROM
       urban_center_4326 AS ghs
    JOIN
       nuts 
    ON 
       st_intersects(nuts.geom, ghs.geom)
    WHERE 
        nuts.shapename = 'Porto Alegre'),
--- Bounding Box that contained the GHS in Porto Alegre
porto_alegre_ghs_bbox AS(
    SELECT 
        st_setsrid(st_extent(geom),4326) as geom_bbox
    FROM 
        porto_alegre_ghs),
flooding_sul_subdivided AS (
        SELECT 
            st_subdivide(geom) as the_geom
        FROM
            flooding_rio_grande_do_sul),
exterior_ring_porto_alegre_v2 AS (
SELECT 
    ST_ExteriorRing((ST_Dump(union_geom)).geom) as geom
FROM (
    SELECT 
        ST_Union(flood.the_geom) as union_geom
    FROM 
        porto_alegre_ghs_bbox as bbox
    JOIN 
        flooding_sul_subdivided as flood
    ON 
        ST_Intersects(flood.the_geom, bbox.geom_bbox)
) AS subquery)
SELECT net.id,
    CASE
        WHEN NOT ST_Contains(flood.geom, net.the_geom)
        THEN net.the_geom
            ELSE st_intersection(net.the_geom, flood.geom)
    END AS  geom,
    net.target,
       net.source,
       cost,
       "unidirectid",
       "bidirectid"
FROM
porto_alegre_net_largest_subset AS net
JOIN exterior_ring_porto_alegre_v2 flood ON
st_intersects(net.the_geom, flood.geom)
WHERE 
  net.the_geom && 
    st_setsrid(
    st_makeenvelope(-51.214287,-30.020226,-51.12934,-29.945862),4326);
----
--- For the network
CREATE INDEX idx_porto_alegre_net_outside_v2 ON porto_alegre_net_outside_v2 USING gist (geom);

CLUSTER porto_alegre_net_outside_v2 USING idx_porto_alegre_net_outside_v2;

--- For the flooding mask
CREATE INDEX flooding_sul_subdivided_idx ON flooding_sul_subdivided USING gist (the_geom);

CLUSTER flooding_sul_subdivided USING flooding_sul_subdivided_idx;

---- Before doing difference
VACUUM(FULL, ANALYZE) porto_alegre_net_outside_v2;
VACUUM(FULL, ANALYZE) flooding_sul_subdivided;
----
CREATE INDEX idx_porto_alegre_net_outside_v3 ON porto_alegre_net_outside_v3 USING gist (geom);

CLUSTER porto_alegre_net_outside_v3 USING idx_porto_alegre_net_outside_v3;

--- For the flooding mask
CREATE INDEX flooding_subdivided_porto_join_idx ON flooding_subdivided_porto_join USING gist (the_geom);

CLUSTER flooding_subdivided_porto_join USING flooding_subdivided_porto_join_idx ;

---- Before doing difference
VACUUM(FULL, ANALYZE) porto_alegre_net_outside_v3;
VACUUM(FULL, ANALYZE) flooding_subdivided_porto_join;

----

CREATE TABLE flooding_symple as 
SELECT st_union(geom) as the_geom FROM flooding_cleaned_porto_union_simple;

CREATE INDEX flooding_symple_idx ON flooding_symple USING gist (the_geom);
CLUSTER flooding_symple USING flooding_symple_idx;

CREATE TABLE difference_outside_flood_v4 AS
SELECT net.id,
        target,
        source,
        cost,
        unidirectid,
        bidirectid,
st_difference(net.geom, flood.the_geom) AS the_geom
FROM porto_alegre_net_outside_v3 AS net,
flooding_symple  AS flood;

-----------
CREATE TABLE porto_alegre_street_united_v3 AS
SELECT *
FROM porto_alegre_street_out_v3
UNION
SELECT *
FROM difference_outside_flood_v4;

--- Final product: porto_alegre_street_united_v2
```


```{sql}
#| connection: eisenberg_connection
#| eval: false


CREATE TABLE subset_post_scenario_bbox AS
SELECT st_setsrid(
            st_makeenvelope(
              -51.214287,-30.020226,-51.12934,-29.945862),4326) AS geom;

```


```{sql}
#| connection: eisenberg_connection
#| eval: false


---- Generate the subset to be visualize

CREATE TABLE porto_alegre_net_largest_subset AS                  
SELECT
  st_intersection(net.the_geom, bbox.geom) 
FROM 
  porto_alegre_net_largest AS net
WHERE 
porto_alegre_net_largest.the_geom && subset_post_scenario_bbox; 
```


```{sql}
#| connection: eisenberg_connection
#| eval: false

SELECT
  st_intersection(net.the_geom, bbox.geom)
FROM 
  porto_alegre_net_largest AS net,
subset_post_scenario_bbox AS bbox;

```



## RQ1: Centrality analysis

>How does road connectivity change after being impacted by flooding based on
connectivity metrics?

```{r}
centrality_pre <- st_read(eisenberg_connection, "centrality_weighted_100_bidirect_cleaned")
```


### Performance

```{r}
library(readODS)
library(ggplot2)
performance <- readODS::read_ods("metrics.ods")
df <- performance |> dplyr::select(c("number_od","method","algorithm","time","max_centrality","count_rows","query","analyze")) |> filter(!is.na(time) & method=='naive')

ggplot(df,aes(x=number_od, y=time, group = algorithm)) +
  geom_line(aes(color=algorithm)) +
   geom_point(aes(color=algorithm))

DT::datatable(subset(df, select=c("number_od","algorithm","time","query","analyze")), 
              class='compact', rownames=FALSE, escape=FALSE, caption='Data description',
              extensions=c("Buttons",'RowGroup'),
              options=list(
                  order=list(list(0, 'asc'), list(2,'asc')),  # Sort by the first column (index 0)
                  rowGroup=list(dataSrc=0),    # Fixed rowGroup
                  dom="Bfrtip",
                  columnDefs = list(list(visible=FALSE, targets= c(3,4))),
                  buttons=c("copy", "csv", "pdf"),
                  initComplete = JS(
                      "function(settings, json) {",
                      "$(this.api().table().header()).css({'background-color': '#d50038', 'color': '#fff'});",
                      "}")
              )
) |> 
    DT::formatStyle("time",
                    background=DT::styleColorBar(range(df$time), '#ee8b8b'),
                    backgroundSize='98% 88%',
                    backgroundRepeat='no-repeat',
                    backgroundPosition='center')
```

### Closeness

```{r}
closseness <-sf::st_read(eisenberg_connection, 
                            layer = "clossness_hospital_porto")
closseness_no_geom <- closseness |>  
                          arrange(ds_cnes, closeness) |>
                          mutate(lng= 
                              unlist(map(geom_hospital,1)),
                           lat=
                              unlist(map(geom_hospital,2)),
                           closeness_norm = 
                          (closseness$closeness - min(closseness$closeness)) / (max(closseness$closeness) - min(closseness$closeness)) * 100,
                          position = rank(-closeness),
                          ds_cnes =stringr::str_to_title(ds_cnes)) |>
                  sf::st_drop_geometry()

DT::datatable(subset(closseness_no_geom, select=c("position","cd_cnes","ds_cnes","closeness")),
              extensions="Buttons",
                         options=list(
                           dom="Bfrtip",
                           buttons=c("copy","csv","pdf"),
                            initComplete = JS(
    "function(settings, json) {",
    "$(this.api().table().header()).css({'background-color': '#d50038', 'color': '#fff'});",
    "}")
                                  )
              ) |> 
    DT::formatStyle("closeness",
              background=DT::styleColorBar(range(closseness_no_geom$closeness),'#ee8b8b'),
                backgroundSize = '98% 88%',
  backgroundRepeat = 'no-repeat',
  backgroundPosition = 'center') 
```


```{r}

# Import he data
## hospital with closenesss values
closseness <-sf::st_read(eisenberg_connection, 
                            layer = "clossness_hospital_porto")
closseness_df <- closseness |>  arrange(ds_cnes, closeness) |>
                    mutate(lng= 
                              unlist(map(geom_hospital,1)),
                           lat=
                              unlist(map(geom_hospital,2)),
                           closeness_norm = 
                          (closseness$closeness - min(closseness$closeness)) / (max(closseness$closeness) - min(closseness$closeness)) * 100,
                          position = rank(-closeness))
## Create Color palette for visualization
pal <- colorQuantile(palette = "OrRd",closseness_df$closeness, n=4 )

## Create leaflet product

icons <- makeAwesomeIcon(
  icon = 'fa-heartbeat',
  iconColor = "#FFFFFF",
  markerColor = "#57142c",
  library = "fa"
)
leaflet(closseness_df) |>
    addProviderTiles(providers$OpenStreetMap.HOT) |>
    addCircles(data =closseness_df , radius = ~sqrt(closeness)*10, fillOpacity = .50, color =~pal(closeness)) |>
  addAwesomeMarkers(data=closseness_df,
                          icon =icons,
                          popup= ~paste0("<b>Código CNES: </b>", cd_cnes, "<br/>",
                                   "<b>Nome: </b>", ds_cnes, "<br/>",
                                   "<b> Closeness</b>:", closeness, "<br/>",
                                   "<b>Longitude: </b>", lng, "<br/>",
                                   "<b>Posição </b>", position, "<br/>"))

```

## RQ2:  Accessibility analysis

> Which healthcare facilities will be most affected by flooding based on accessibility
metrics?

## RQ3: Critical infrastructures

> Where are the most critical infrastructures located for accessing health facilities
to reinforce urban resilience against flooding?